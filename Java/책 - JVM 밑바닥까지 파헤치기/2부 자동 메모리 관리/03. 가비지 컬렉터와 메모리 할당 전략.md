## 가비지 컬렉터와 메모리 할당 전략
스택 프레임에 할당되는 메모리 크기는 기본적으로 클래스가 만들어질 때 결정된다. 
따라서, 이 영역의 메모리 할당과 회수는 결정적이라서 어떻게 회수할지는 고민하지 않아도 된다. 
메서드가 끝나거나 스레드가 종료되면 자연스럽게 회수될 것이다.  
하지만, 자바 힙과 메서드 영역은 불확실한 게 아주 많다. 
같은 인터페이스라도 구현한 클래스마다 요구하는 메모리 크기가 다를 수 있다. 
하나의 메서드에서도 어떤 조건 분기를 실행하느냐에 따라 메모리 요구량이 달라질 수 있다. 
프로그램이 어떤 객체를 생성할지, 얼마나 많이 만들지는 오직 런타임에만 알 수 있는 것이다. 
그래서 이 메모리 영역들의 할당과 회수는 동적으로 이루어진다. 가비지 컬렉터는 바로 이런 영역을 관리하는데 집중한다.  
<br>

### 참조 카운팅 알고리즘
1. 객체를 가리키는 참조 카운터를 추가한다.
2. 참조하는 곳이 하나 늘어날 때마다 카운터 값을 1씩 증가시킨다.
3. 참조하는 곳이 하나 사라질 때마다 1씩 감소시킨다.
4. 카운터 값이 0이된 객체는 더는 사용될 수 없다.

**JVM에서는 참조 카운팅을 쓰지 않는다.**  
이 간결한 알고리즘에도 고려해야 할 특이 상황이 적지 않고, 모든 상황에서 문제없이 동작하게 하려면 계산할 게 상당히 늘어나기 때문이다.
예를 들어 간단한 참조 카운팅만으로는 순환 참조(circular reference) 문제를 풀기 어렵다. 

```JAVA
public class ReferenceCountingGC {
  public Object instance = null;
  private static final int _IMB = 1024 * 1024;
  // 메모리를 많이 차지하여 GC 로그에서 회수 여부를 명확히 알아볼 수 있게 한다.
  private bytel] bigSize = new byte[2 * _1MB];

  public static void testGC() {

    // 두 객체 생성
    ReferenceCountingGC objA = new ReferenceCountingGC();
    ReferenceCountingGC objB = new ReferenceCountingGC():

    // 내부 필드로 서로를 참조
    objA.instance = objB;
    objB.instance = objA;

    // 참조 해제
    objA = null;
    objB = null;

    // 이 라인에서 GC가 수행된다면 0bjA와 ObjB가 회수될까?
    System.gc();
  }

  public static void main(String[] args) {
    testGC();
  }
}
```
objA와 objB 객체에는 모두 instance라는 필드가 있다.  
코드 objA.instance = objB와 objB.Instance = objA 에서 이 필드들에 값을 할당한 다음 두 객체의 참조를 해제했다.  
이 시점부터 외부 에서 두 객체에 접근할 길이 사라진다.  
하지만, 서로를 참조하고 있기 때문에 참조 카운터는 아직 0이 아니다.  
따라서 참조 카운팅 알고리즘으로는 둘을 회수하지 못 한다.(JVM에서는 해당 알고리즘을 사용하지 않으므로 메모리를 회수할 수 있다.)  

참조에 대한 종류 : 강한 참조, 부드러운 참조, 약한 참조, 유령 참조, 파이널 참조
<br>
<br>

### 도달 가능성 분석 알고리즘(reachability analysis algorithm) (p.97)
```java
GC Root
  │
  ├── A
  │   ├── B
  │   ├── C
  │       ├── D
  │
  ├── E

X── F   (어떤 참조도 받지 않음 → GC 대상)
    ├── G
        ├── H
```
자바, C# 등 오늘날의 주류 프로그래밍 언어들은 모두 객체 생사 판단에 도달 가능한 분석 알고리즘을 이용한다.  
이 알고리즘의 기본 아이디어는 GC 루트라고 하는 루트 객체들을 시작 노드 집합으로 쓰는 것이다. 시작 노드들에서 출발하여 참조하는 다른 객체들로 탐색해 들어간다.  
탐색 과정에서 만들어지는 경로를 참조 체인(reference chain)이라고 한다. 그리고 어떤 객체와 GC 루트 사이를 이어주는 참조 체인이 없다면, 회수 대상이 된다.  
<br>

자바에서 GC 루트로 이용할 수 있는 개체는 정해져 있다.
* 가상 머신 스택에서 참조하는 객체 : 현재 실행중인 메서드에서 쓰는 매개 변수, 지역 변수, 임시 변수 등
* 메서드 영역에서 클래스가 정적 필드로 참조하는 객체 : 자바 클래스의 참조 타입 정적 변수
* 메서드 영역에서 상수로 참조되는 객체 : 문자열 테이블 안의 참조
* 네이티브 메서드 스택에서 JNI가 참조하는 객체
* 자바 가상 머신 내부에서 쓰이는 참조 : 기본 데이터 타입에 해당하는 Class 객체, 일부 상주 예외 객체(NullPointerException, OutOfMemoryError 등), 시스템 클래스 로더
* 동기화 락(synchronized 키워드)으로 잠겨있는 모든 객체
* JVM 내부 상황을 반영하는 JMXBean : JVMTI에 등록된 콜백, 로컬 코드 캐시 등

도달 가능성 분석 알고리즘이 **도달 불가능**으로 판단한 객체라고 해서 반드시 죽어야 하는건 아니다.  
도달 가능성 분석으로 GC 루트와 연결된 참조 체인을 찾지 못한 객체에는 첫 번째 표시가 이루어지며 이어서 필터링이 진행된다.  
필터링 조건은 종료자, 즉 finalize() 를 실행해야 하는 객체인지 판단하는 것이다. finalize()가 필요없는 객체이거나 VM이 finalize()를 이미 호출한 경우 모두 '실행할 필요 없음' 으로 처리한다.  
finalize()를 실행해야하는 객체로 판명되면, F-Queue라는 대기열에 추가된다. 그러면 VM이 나중에 우선순위가 낮은 종료자 스레드를 생성해 F-Queue에 들어있는 객체객체들의 finalize() 를 실행한다.  
참고로 VM은 이 메서드를 시작만 시킬 뿐 끝날 때까지 기다려주진 않는다. finalize() 메서드는 죽음에 직면한 객체가 부활할 수 있는 마지막 기회다.  
예를 들어, this를 특정 클래스 변수나 다른 객체의 인스턴스 변수에 할당하면 된다. 이렇게하면, 두 번째 표시 과정에서 '회수 대상' 목록에서 제외될 것이다.(p.100)  
하지만, 기회는 한 번뿐이다. 어떤 객체든 시스템이 finalize()를 호출해주는건 오직 한 번뿐이기 때문이다.  
<br>
<br>

### 메서드 영역 회수하기(p.102)
메서드 영역의 가비지 컬렉션은 크게 두 가지를 회수한다. 더이상 사용되지 않는 '상수'와 '클래스'다.  
다 쓴 '상수'를 회수하는 방법도 자바 힙에서 객체를 회수하는 방법과 매우 비슷하다.  
예를 들어, 문자열 "JAVA"가 상수 풀에 들어있으나, 현재 시스템에서 값이 "JAVA"인 문자열 객체는 하나도 없다고 해보자.  
이 시점에 회수가 시작되면, 가비지 컬렉터는 "JAVA" 상수를 상수 풀에서 치워야 한다고 판단할 것이다. 
상수 풀에 있는 다른 클래스(인터페이스 포함), 메서드, 필드의 심벌 참조도 비슷한 방법으로 회수한다.  
<br>
다 쓴 상수인지 판단하는 일은 비교적 간단하지만, 더 이상 쓰이지 않는 '클래스' 인지 판단하는 조건은 더 까다롭다.  
다음 세 조건을 동시에 만족해야 한다.  
* 이 클래스의 인스턴스가 모두 회수되었다. 즉, 자바 힙에는 해당 클래스와 하위 클래스의 인스턴수가 하나도 존재하지 않는다.
* 이 클래스를 읽어들인 클래스 로다가 회수되었다. 이 조건은 OSGi나 JSP 리로딩처럼 세심하게 설계된 대안 클래스 로더 없이는 충족하기 어렵다.
* 이 클래ㅔ스에 해당하는 java.lang.Class 객체를 아무 곳에서도 참조하지 않고, 리플렉션 기능으로 이 클래스의 메서드를 이용하는 곳도 전혀 없다.

JVM은 위 세 조건에 부합하는 쓸모없는 클래스들을 회수하도록 허용한다. 하지만, 반드시 회수하지는 않는다.  
핫스팟 가상 머신은 클래스 회수 여부를 제어할 수 있도록 -Xnoclassgc 매게 변수를 제공한다.

### 세대 단위 가비지 컬렉션 (p.104)
기본적으로 두 가지 가설이 뿌리를 이룬다.
1. 약한 세대 가설(Weak Generational Hypothesis) : 대부분의 객체는 일찍 죽는다.
2. 강한 세대 가설(Strong Generational Hypothesis) : 가비지 컬렉션 과정에서 살아남은 횟수가 늘어날수록 더 오래 살 가능성이 커진다.

나머지 하나의 가설
교차 세대 참조 가설(Inter-generational Reference Hypothesis) : 대부분의 객체는 다른 세대의 객체를 참조하지 않는다.  
<br>

### 마크 스윕 알고리즘 (p.107)
이 알고리즘은 작업을 표시(mark)와 쓸기(sweep)라는 두 단계로 나눠 진행한다.  
먼저 회수할 객체들에 모두 표시한 다음, 표시된 객체들을 쓸어 담는 식이다. 또는 반대로 살릴 객체에 표시하고 표시되지 않은 객체를 회수하기도 한다. 표시 단계는 객체가 쓰레기인지 판단하는 과정이다.  
마크 스윕 알고리즘이 가장 기본적인 알고리즘인 이유는 뒤에 나온 컬렉션 알고리즘들 대부분이 이를 기초로 그 단점을 보완하는 식으로 발전했기 때문이다.  

**마크 스윕 알고리즘의 2가지 단점**
1. 실행 효율이 일정하지 않다. 자바 힙이 다량의 객체로 가득 차 있고, 그 대부분이 회수 대상이라면 표시하는 일과 회수하는 일이 모두 커진다. 즉, 객체가 많아질수록 작업 효율이 떨어지는 구조다.
2. 메모리 파편화가 심하다. 가바지 컬렉터가 쓸고 간 자리에는 불연속적인 메모리 파편이 만들어진다. 파편화가 너무 심하면 프로그램이 큰 객체를 만들려 할 때 충분한 크기의 연속된 메모리를 찾기가 점점 어려워지고, 그 결과 또 다른 가비지 컬렉션을 유발한다.

<br>

### 마크 카피 알고리즘








