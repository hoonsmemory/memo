## 자바 메모리 영역과 메모리 오버플로

### JVM 구조 (p.59)
[Java/JVM 정리.md](https://github.com/hoonsmemory/memo/blob/e6639736857576ea2a538b9116465bde6cddfd7c/Java/JVM%20%EC%A0%95%EB%A6%AC.md)


### 객체 생성 (p.67)
자바 가상 머신이 New 명령에 해당하는 바이트코드를 만나면, 이 명령의 매개 변수가 상수 풀 안의 클래스를 가리키는 **심벌 참조**인지 확인한다.  
그런 다음 이 심벌 참조가 뜻하는 클래스가 로딩, 해석, 초기화되었는지 확인한다. 준비되지 않은 클래스라면 로딩부터 해야 한다.  
로딩이 완료된 클래스라면 새 객체를 담을 메모리를 할당한다. 객체에 필요한 메모리 크기는 클래스를 로딩하고 나면 완벽하게 알 수 있다.  
객체용 메모리 공간 할당은 자바 힙에서 특정 크기의 메모리 블록을 잘라 주는 일이라 할 수 있다.  

***심벌 참조**  : 자바 프로그램이 컴파일될 때 생성된 간접적인 참조 방식으로, 클래스 파일에서 사용되는 특정 이름이나 정보를 참조하는 기법.  
<br>

<p align="center">
  <img src="https://github.com/user-attachments/assets/ad1926fb-4fe9-4c41-bfed-0dfbb972a49f">
</p>

자바 힙이 완벽히 규칙적이라고 가정하면 사용 중인 메모리는 모두 한쪽에, 여유 메모리는 반대편에 자리하며, 포인터가 두 영역의 경계인 가운데 지점을 가리키게 될 것이다.(전역 포인터) 이 상태에서 메모리를 할당하면 포인터를 여유 공간쪽으로 정확히 객체 크기만큼 이동시키게 된다. 이러한 할당 방식을 포인터 밀치기(bump the pointer)라고 한다.  

하지만, 자바 힙은 사용중인 메모리와 여유 메모리가 뒤섞여 있어서 포인터를 밀쳐 내기가 그리 간단하지 않다.  
상황에 맞게 적절한 방법으로 채택한다.(추후 배울 내용..)  
<br>

<p align="center">
  <img src="https://github.com/user-attachments/assets/3c1792d9-f2a2-4e47-af42-8b13dde8b14a">
</p>

가상머신에서 객체 생성은 매우 빈번히 일어난다. 더욱이 멀티스레딩 환경에서는 여유 메모리의 시작 포인터 위치를 수정하는 단순한 일도 스레드 안전하지 않기 때문에 여러 스레드가 동시에 객체를 생성하려고 할 때 문제가 생길 수 있다.  
예컨대 한 스레드가 요청한 객체A를 위해 메모리를 할당하는 과정에서, 포인터의 값을 아직 수정하기 전에 다른 스레드가 객체B용 메모리를 요청할 수 있다.  
크게 메모리 할당을 동기화하는 방법과 스레드마다 다른 메모리 공간을 할당하는 방법이 있다.  

***TLAB(스레드 로컬 할당 버퍼)** : 스레드 각각마다 자바 힙 내에 작은 크기의 전용 메모리를 미리 할당받아 놓은 것.  

메모리 할당이 끝난 후 가상머신은 할당받은 공간을 0으로 초기화한다.  
그 다음 객체에 필요한 설정을 한다. 예를 들어 어느 클래스의 인스턴스인지, 클래스의 메타 정보느 어떻게 찾는지, 이 객체의 해시코드는 무엇인지 GC 세대 나이는 얼마인지 등의 정보가 여기에 속한다. 이러한 정보들은 각 객체의 헤더에 저장된다.  
메모리 할당이 일어난 후 최종적으로 <init>() 메서드까지 실행되면 객체가 완성된다.  
<br>

### 객체의 메모리 레이아웃 (p.72)
<p align="center">
  <img src="https://github.com/user-attachments/assets/30094585-f7a9-4bbe-8661-3d0a8160c49f">
</p>

핫스팟 가상머신은 객체 헤더, 인스턴스 데이터, 길이 맞추기용 정렬 패딩(alignment padding) 세 부분으로 나누어 힙에 저장한다.  

**객체 해더**  
핫스팟 가상머신은 객체 헤더에 두 유형의 정보를 담는다.  
첫 번째 유형은 객체 자체의 런타임 데이터다. 해시 코드, GC 세대 나이, 락 상태 플래그, 스레드가 점유하고 있는 락들, 편향된 스레드의 아이디, 편향된 시각의 타임스탬프 등이다. 이 부분을 **마크 워드(mark word)** 라고 한다. 객체는 아주 많은 런타임 데이터를 필요로 해서 32비트나 64비트 구조에 전부 담을 수는 없다.  
따라서, 마크 워드의 데이터 구조는 동적으로 의미가 달라진다. 작은 공간에 가능한 많은 정보를 담고, 객체 상태에 따라 공간을 재활용할 수도 있게 하기 위해서다.  
32비트 핫스팟 가상 머신에서는 마크 워드의 저장 공간 중 25비트는 객체 해시 코드를 저장하고, 4비트는 객체의 세대 나이를 저장하고, 1비트는 0으로 고정, 마짐가 2비트는 락 플래그를 저장하는데 쓰인다.  

그 다음에는 **클래스 워드(klass word)** 가 있다. 클래스 워드에는 객체의 클래스 관련 메타데이터를 가리키는 클래스 포인터가 저장된다. 자바 가상머신은 이 포인터를 통해 특정 객체가 어느 클래스의 인스턴스인지 런타임에 알 수 있다. 모든 가상머신 구현이 클래스 포인터를 객체 헤더에 저장하지는 않는다. 달리 말하면 객체의 메타데이터 정보를 반드시 객체 자체에서 찾아야 하는 건 아니다.  
<br>

**인스턴스 데이터**  
객체 레이아웃의 두 번째 부분은 인스턴스 데이터로 객체가 실제로 담고있는 정보다. 코드에 정의한 다양한 타입의 필드 관련 내용과 부모 클래스 유무, 부모 클래스에서 정의한 모든 필드가 이 부분에 기록된다.  
핫스팟 가상머신은 기본적으로 long double, int, short char, byte boolean, 일반 객체 포인터 순으로 할당한다. 보다시피 기본 할당 전략에서는 길이가 같은 필드들은 항상 같이 할당되고 저장된다. 필드 길이가 같다면, 부모 클래스에서 정의된 필드가 자식 클래스의 필드보다 앞에 배치된다.  

***-XX:(+ : 활성화, - : 비활성화)CompactFields**  
핫스팟 가상머신 옵션 중 하나로, 자바 객체의 메모리 레이아웃을 최적화하여 메모리 사용량을 줄이기 위한 기능이다.  

**[예시]**  
**CompactFields 비활성화**  
[byte (1 byte)] [padding (3 bytes)] [int (4 bytes)] [short (2 bytes)] [padding (6 bytes)] [long (8 bytes)]  
24 bytes 사용

**CompactFields 활성화**  
[byte (1 byte)] [short (2 bytes)] [padding (1 byte)] [int (4 bytes)] [long (8 bytes)]  
16 bytes 사용  
<br>

**정렬 패딩**  
마지막 세 번쨰 부분은 정렬 패딩이다. 이 부분은 전재하지 않을 수도 있으며, 특별한 의미 없이 자리를 확보하는 역할만 한다.  핫스팟 가상머신의 자동 메모리 관리 시스템에서 객체의 시작 주소는 반드시 8바이트의 정수배여야 한다. 달리 말하면, 모든 객체의 크기가 8바이트의 정수배여야 한다는 뜻이다. 
<br>

### 객체에 접근하기 (p.75)
대다수의 객체는 다른 객체 여러 개를 조합해 만들어진다. 그리고 자바 프로그램은 스택에 있는 참조 데이터를 통해 힙에 들어있는 객체들에 접근해 이를 조작한다. 객체에 접근하는 방식은 가상머신에서 구현하기 나름이며, 주로 핸들이나 다이렉트 포인터를 사용해 구현한다.

**핸들 방식**  
<p align="center">
  <img src="https://github.com/user-attachments/assets/e9d4e7ad-f4c3-453f-a39a-c8900981a135">
</p>

**핸들 방식의 가장 큰 장점은 참조에 '안정적인' 핸들의 주소가 저장된다는 것이다.** 가비지 컬렉션 과정에서 객체가 이동하는 일은 아주 흔하다. 핸들을 이용하면 이렇게 객체의 위치가 바뀌는 상황에서도 참조 자체는 손댈 필요가 없다. 그 대신 핸들내의 인스턴스 데이터 포인터만 변경하면 된다. 
<br>

**다이렉트 포인터 방식**  
<p align="center">
  <img src="https://github.com/user-attachments/assets/0ee01449-8e0f-4408-9a06-4b20833e8de3">
</p>

다이렉트 포인터 방식에서는 자바 힙에 위치한 객체에서 인스턴스 데이터뿐 아니라 타입 데이터에 접근하는 길도 제공해야 한다. 스택의 참조에는 객체의 실제 주소가 저장되어 있다. **다이렉트 포인터 방식의 가장 큰 장점은 속도다.** 핸들을 경유하는 오버헤드가 없기 때문이다. 자바에서는 다른 객체에 접근할 일이 아주 많기 때문에 이 오버헤드도 실행 시간에 영향을 크게 줄 수 있다. 핫스팟 가상머신은 주로 다이렉트 포인터 방식을 이용한다. 


