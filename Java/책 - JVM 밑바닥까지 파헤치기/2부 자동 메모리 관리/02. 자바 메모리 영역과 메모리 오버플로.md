## 자바 메모리 영역과 메모리 오버플로

### JVM 구조 (p.59)
[Java/JVM 정리.md](https://github.com/hoonsmemory/memo/blob/e6639736857576ea2a538b9116465bde6cddfd7c/Java/JVM%20%EC%A0%95%EB%A6%AC.md)


### 객체 생성 (p.67)
자바 가상 머신이 New 명령에 해당하는 바이트코드를 만나면, 이 명령의 매개 변수가 상수 풀 안의 클래스를 가리키는 **심벌 참조**인지 확인한다.  
그런 다음 이 심벌 참조가 뜻하는 클래스가 로딩, 해석, 초기화되었는지 확인한다. 준비되지 않은 클래스라면 로딩부터 해야 한다.  
로딩이 완료된 클래스라면 새 객체를 담을 메모리를 할당한다. 객체에 필요한 메모리 크기는 클래스를 로딩하고 나면 완벽하게 알 수 있다.  
객체용 메모리 공간 할당은 자바 힙에서 특정 크기의 메모리 블록을 잘라 주는 일이라 할 수 있다.  

***심벌 참조**  : 자바 프로그램이 컴파일될 때 생성된 간접적인 참조 방식으로, 클래스 파일에서 사용되는 특정 이름이나 정보를 참조하는 기법.  
<br>

<p align="center">
  <img src="https://github.com/user-attachments/assets/ad1926fb-4fe9-4c41-bfed-0dfbb972a49f">
</p>

자바 힙이 완벽히 규칙적이라고 가정하면 사용 중인 메모리는 모두 한쪽에, 여유 메모리는 반대편에 자리하며, 포인터가 두 영역의 경계인 가운데 지점을 가리키게 될 것이다.(전역 포인터) 이 상태에서 메모리를 할당하면 포인터를 여유 공간쪽으로 정확히 객체 크기만큼 이동시키게 된다. 이러한 할당 방식을 포인터 밀치기(bump the pointer)라고 한다.  

하지만, 자바 힙은 사용중인 메모리와 여유 메모리가 뒤섞여 있어서 포인터를 밀쳐 내기가 그리 간단하지 않다.  
상황에 맞게 적절한 방법으로 채택한다.(추후 배울 내용..)  
<br>

<p align="center">
  <img src="https://github.com/user-attachments/assets/3c1792d9-f2a2-4e47-af42-8b13dde8b14a">
</p>

가상머신에서 객체 생성은 매우 빈번히 일어난다. 더욱이 멀티스레딩 환경에서는 여유 메모리의 시작 포인터 위치를 수정하는 단순한 일도 스레드 안전하지 않기 때문에 여러 스레드가 동시에 객체를 생성하려고 할 때 문제가 생길 수 있다.  
예컨대 한 스레드가 요청한 객체A를 위해 메모리를 할당하는 과정에서, 포인터의 값을 아직 수정하기 전에 다른 스레드가 객체B용 메모리를 요청할 수 있다.  
크게 메모리 할당을 동기화하는 방법과 스레드마다 다른 메모리 공간을 할당하는 방법이 있다.  

***TLAB(스레드 로컬 할당 버퍼)** : 스레드 각각마다 자바 힙 내에 작은 크기의 전용 메모리를 미리 할당받아 놓은 것  



