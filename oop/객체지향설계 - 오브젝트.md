## 절차적인 설계

![스크린샷 2024-10-11 오전 8 47 20](https://github.com/user-attachments/assets/bd9ce63b-6089-443c-a596-2af22938ad9e)
![스크린샷 2024-10-11 오전 8 46 36](https://github.com/user-attachments/assets/fd578805-bdfe-4e59-af9b-3338886be074)
![스크린샷 2024-10-11 오전 8 47 35](https://github.com/user-attachments/assets/bfdde544-eca3-44de-916d-df944e10750d)
절차적인 코드는 하나의 메서드(reserveScreening)안에 실행 순서대로 배치되고 모든 제어 흐름을 갖는다.(중앙집중식 제어 스타일)  
하나의 메서드 안에서 여러 로직(도메인)을 실행하므로 단일 책임 원칙을 위배하고, 변경이 발생하면 변경할 클래스뿐만 아니라 여러 곳의 코드를 수정해줘야 한다.  
<br>
<br>
![스크린샷 2024-10-11 오전 9 02 57](https://github.com/user-attachments/assets/22c1de29-cb65-437c-bfd2-0aef3c452bed)
절차적인 방식의 가장 큰 문제점은 **데이터를 구현한 코드의 수정에 취약하다는 점**이다.  
<br>
<br>
![스크린샷 2024-10-11 오전 9 03 10](https://github.com/user-attachments/assets/b2cc8ef1-bb6c-42fc-b1ff-f10035149f6b)
![DiscountCondition을 수정하면 ReservationService도 수정](https://github.com/user-attachments/assets/9a5fbc3b-4d17-4ced-9be6-4daa64d4d440)
절차적인 방식에서는 여러 프로세스가 데이터를 공유하기 때문에 데이터가 바뀌면 데이터에 의존하는 하나 이상의 프로세스가 동시에 수정되는 문제가 발생한다.  
조합 조건을 추가하기 위해 데이터인 DiscountCondition 클래스를 수정했고, 그 영향으로 데이터를 사용하는 프로세스인 ReservationService 클래스가 함께 수정되었다.  
이렇게 **데이터를 수정할 때 프로세스도 함께 수정해야 한다는 점이 절차적인 설계가 가지는 전형적인 문제다.**  

## 의존성
![의존성Dependency](https://github.com/user-attachments/assets/1811092b-085b-4314-8b1e-b6056adac466)


그림에서 보는 것처럼 A와 B라는 모듈이 있을 때 A가 B를 사용한다면 A가 B에 의존한다.  
**의존성**이라는 용어 안에는 **변경**이라는 개념이 포함되어 있다는 사실이 매우 중요하다.  
즉 A가 B에 의존한다는 말에는 B가 변경될 때 A도 함께 변경될 가능성(다양한 의존성이 존재하기 때문에 항상 변경되지는 않음)이 있다는 의미가 포함되어있다.  

![의존성은 변경의 이유를 의미](https://github.com/user-attachments/assets/4ba02138-0fc8-4ea5-996b-c01af0518814)
위 그림처럼 외부 클래스의 클래스명이 변경되거나 내부 구조가 변경되거나 메서드 시그니처가 변경되는 등 외존하고 있는 객체때문에 변경이 발생할 수 있다.  


## 의존성의 방향과 변경의 방향
![스크린샷 2024-10-11 오전 9 46 59](https://github.com/user-attachments/assets/d794b5f6-b5b6-4dd5-8fd4-32cb61e562b0)
![의존성의 방향과 변경의 방향](https://github.com/user-attachments/assets/e2d8b05b-d498-4bfd-a0ab-6cbf467a92e2)
프로세스는 데이터에 의존하고 변경의 방향은 의존성의 방향과 반대가 된다.  
변경과 의존성이 서로 관련이 있기 때문에 결과적으로 **변경하기 쉬운 설계를 만들기 위해서는 의존성을 통제해야 한다.**  
  
  
## 추측에 의한 설계 전략(Design-By-Guessing Strategy)
![스크린샷 2024-10-11 오전 10 00 33](https://github.com/user-attachments/assets/2725ea40-6f01-4496-9d16-7d1bb1a7c60b)
![파급효과 제어의 어려움](https://github.com/user-attachments/assets/41b1ffb5-acb2-4d31-833b-c9a0bd53cca8)
문맥과 무관하게 어떤 상황에서도 데이터를 사용 가능하도록 내부의 데이터를 그대로 드러내는 설계 방식을 추측에 의한 설계전략이라고 한다.  
변경하기 쉬운 설계를 만들기 위해서는 데이터 변경으로 인한 파급효과를 막는 것이 핵심이다.  

**☞절차적인 방식으로 부여하는 코드는 데이터를 수정할 때 프로세스가 함께 수정된다는 단점을 가지고 있다.**  

## 분리되어있는 데이터와 프로세스의 문제 해결
![데이터와 프로세스의 분리](https://github.com/user-attachments/assets/d4996a89-62a1-4dc8-8818-85c1056a5d14)
![데이터를 사용하는 프로세스를 데이터 내부로 이동](https://github.com/user-attachments/assets/aa2b518e-ac01-446b-8517-aee76f3a8fe8)
문제의 근본 원인이 프로세스와 데이터를 별도의 모듈로 분리했기 때문이라면, 이 문제를 해결할 수 있는 가장 좋은 방법은 데이터와 프로세스를 하나의 모듈로 합치는 것이다.  
즉, 데이터를 변경할 때 다른 모듈 안에 포함된 프로세스가 함께 변경되는 상황이 문제이기 때문에 데이터와 프로세스를 동일한 모듈 안에 위치시켜서 하나의 모듈 안에서만 변경이 발생하도록 개선하면 코드를 수정하기가 쉬워질 것이다.  

**데이터와 프로세스의 통합이 객체지향의 바탕을 이루는 가장 기본적인 개념이다.**  

## 리팩토링
![리팩토링 규칙](https://github.com/user-attachments/assets/85f8842a-ff44-4c8f-8188-715d79438973)
![스크린샷 2024-10-11 오전 10 38 40](https://github.com/user-attachments/assets/4b301e31-64f7-434c-b41b-6d91704cb298)



## 리팩토링-1. 책임의 이동
![객체지향 용어로 표현하면](https://github.com/user-attachments/assets/27d47c26-e6f0-4575-b86e-1514a673fd75)
![책임 이동시키기](https://github.com/user-attachments/assets/f9fa0dff-bc1f-4e55-92a7-817cd1684974)
![자기 자신을 책임지는 객체](https://github.com/user-attachments/assets/9fd09577-87c6-45ed-8194-70c8874b26f5)
데이터를 사용하는 로직을 데이터를 보유한 클래스 쪽으로 옮기면 데이터가 수정될 때 변경의 영향 범위를 데이터 클래스 내부로 제한할 수 있게 된다.  
책임을 데이터로 이동하여 DiscountCondition이 변경될 때 ReservationService에 영향이 없도록 한다.  
<br>
<br>
## 데이터와 객체의 차이
![스크린샷 2024-10-11 오전 10 56 23](https://github.com/user-attachments/assets/1e00e423-3e75-4ea1-b8bf-07aecf75b911)
![데이터를 외부에 제공하고 외부에서 판단하고 결정하는 수동적인 존재](https://github.com/user-attachments/assets/06cd1e3f-e053-45a4-888c-7b1accab27b0)
![스크린샷 2024-10-11 오전 10 56 59](https://github.com/user-attachments/assets/14132340-2d26-4574-b2c9-93e176857e69)
**로직의 특성에 따라서 클래스의 인스턴스는 데이터가 될 수도 있고 객체가 될 수도 있다.**  
로직이 클래스의 인스턴스를 수동적인 존재로 만든다면, 이 클래스의 인스턴스는 데이터가 된다. (단순히 데이터를 외부에 제공하고 외부의 판단하고 결정에 전적으로 의존)  
로직이 클래스의 인스턴스를 능동적인 존재로 만든다면, 이 클래스의 인스턴스는 객체가 된다. (자기 자신의 상태를 직접 관리하고 스르로 판단하고 결정하는 자율적인 존재)  

인스턴스가 다른 객체의 판단에 의존하거나 세세한 의사결정을 외부에 의존한다면 클래스로 구현됐다고 하더라도 그 인스턴스는 데이터라고 불러야 한다.  
**자기 스스로의 원칙에 따라 일을 하거나 자기 자신을 통제할 수 있는 객체를 설계하는 것이 객체지향의 기본 철학이다.**  

## 리팩토링-2. 의존성 줄이기
![연관 관계 추가하기](https://github.com/user-attachments/assets/6b198e36-92d8-4d1a-baa5-be74963f6d34)
![의존성 줄이기](https://github.com/user-attachments/assets/b0d5d108-9ea1-4668-9eab-6168b181d9cf)
![스크린샷 2024-10-11 오전 11 14 34](https://github.com/user-attachments/assets/ddd1d2cd-6604-48b6-83df-e7c6346872c8)
![책임 이동하기](https://github.com/user-attachments/assets/08b4bb4d-0513-4a0e-bb4b-6b990e964a65)
![스크린샷 2024-10-11 오전 11 21 45](https://github.com/user-attachments/assets/b85a1d97-c583-4a11-ac06-2874f3c79d13)


기존 ReservationService에서는 DiscountPolicy와 DiscountCondition 두 개의 클래스에 의존하고 있었다.  
객체지향 설계에서는 의존성을 최대한 줄여야 한다.  
따라서 ReservationService -> DiscountPolicy -> DiscountCondition 구조로 변경이 필요하다. (ReservationService에서 호출하고 있던 findDiscountCondition 메서드를 DiscountPolicy로 옮겨 의존성을 낮춘다.)  

## 객체지향 설계 원칙
**결과적으로 객체지향 설계는 요구사항이 변경될 때 코드를 보다 쉽고 안전하게 수정하기 위함이다.**  

#### 1. 다른 객체의 요청을 처리하기 위해 필요한 행동(협력에 필요한 행동)을 먼저 결정하고, 행동에 적합한 객체를 나중에 선택하라
![스크린샷 2024-10-11 오후 2 51 54](https://github.com/user-attachments/assets/5abd7b24-28c8-4e27-a2ee-91521899da4d)
![행동을 구현하는데 적합한 데이터를 결정](https://github.com/user-attachments/assets/48c1de7b-cad4-454c-9313-5cf3ae080170)
![스크린샷 2024-10-11 오후 2 52 09](https://github.com/user-attachments/assets/9d990609-cf34-4528-a2f2-e55e2dd6d958)


객체의 행동은 고립된 상태가 아닌 다른 객체와의 협력이라는 문맥 안에서 결정해야 한다.  
클라이언트의 요청을 먼저 결정한 후에 이 요청을 처리할 객체를 나중에 선택해야 한다.  

위 그림처럼 "할인 금액을 계산하라" 라는 요청이 먼저 존재하고 이 요청을 처리하기에 적합한 객체(DiscountPolicy)를 나중에 선택해야 한다. **(행동이 객체를 결정)**  
**행동을 먼저 결정하고 객체를 나중에 선택하는 방식으로 설계하면 ,변경에 유연하고 필요한 요소만 포함하는 클래스를 얻을 수 있다.**  
행동이 결정되면 앞에서 살펴본 원칙에 따라 행동을 부연하는데 적합한 데이터를 선택하면 된다. 
이렇게 데이터를 나중에 선택하면, 데이터가 변경되더라도 외부에 영향이 미치지 않는다.  

**협력 : 객체가 다른 객체에게 도움을 얻기 위해 요청하고 응답하는 과정**  

#### 2. 객체의 행동을 먼저 구현하고, 행동에 필요한 데이터를 나중에 선택하라
![절차적인 설계 다시 살펴보기](https://github.com/user-attachments/assets/c0940bb2-9893-4de6-8dd8-62a0400ea6fb)
![절차적인 설계 다시 살펴보기](https://github.com/user-attachments/assets/37800523-96e1-48bb-8643-16ec1d1abb1b)


절차적인 설계에서는 데이터(DiscountPolicy)와 프로세스(ReservationService)를 독립적인 단위로 나눠서 설계를 한다.  
사용될 목록을 고려하지 않고 데이터를 설계하기 때문에 모든 경우에 사용 가능하도록 Getter, Setter를 추가한다.  
이런 추측에 의한 설계 전략이 나쁜 이유는 겉으로 보기에는 필드를 캡슐화한것처럼 보이지만 실제로는 Getter, Setter를 통해 클래스 내부를 그대로 드러내고 있기 때문이다.  
데이터의 구조가 프로세스에 그대로 노출되기 때문에 데이터의 내부 구조가 수정되면 데이터를 사용하는 프로세스도 함께 수정될 수밖에 없다.  
**따라서, 변경으로 인한 문제를 해결하기 위해서는 데이터와 프로세스를 하나의 모듈 안에 함께 작성해야한다. (책임의 이동)**  

![스크린샷 2024-10-11 오후 2 37 38](https://github.com/user-attachments/assets/068e38cf-d784-4a32-b0b1-2dd94d9617be)
설계를 개선하기 전에는 내부의 데이터 구조에 의존했지만, 설계를 개선한 후에는 외부에 공개하는 메서드에 의존한다.  
**데이터를 자유롭게 수정하기 위해서는 외부 객체가 행동에 의존하도록 만들어야 한다.**  
외부 객체가 데이터에 의존하지 않도록 만드는 가장 좋은 방법은 데이터를 결정하기 전에 먼저 행동부터 결정하는 것이다.  
데이터가 없는 상태에서 행동을 먼저 결정하면 외부에서는 데이터에 대해서는 알 수 없기 때문에 행동에 의존할 수 밖에 없다.  


![스크린샷 2024-10-11 오후 2 41 49](https://github.com/user-attachments/assets/e3334651-1484-47d7-b606-995b65e535cb)
![외부 객체의 요청에 용답하기 위해 필요](https://github.com/user-attachments/assets/cf7ee698-c059-44a7-86c5-65d56953acd7)
![데이터가 아닌 행동에 초점](https://github.com/user-attachments/assets/beb51a15-812b-47cd-890e-e8812568a8c2)

외부 객체의 요청에 응답하기 위한 메서드(행동)를 먼저 구현 후 메서드에 필요한 데이터를 추가한다.  

## 객체지향 설계 순서
![협력에 필요한 행동을 먼저 결정하고](https://github.com/user-attachments/assets/064e5aff-5de3-4782-a176-9bfb532bc98e)
![스크린샷 2024-10-11 오후 3 04 54](https://github.com/user-attachments/assets/8bfd490e-ce92-48f7-86b1-dafb2f3b7642)
![스크린샷 2024-10-11 오후 3 05 12](https://github.com/user-attachments/assets/d233cc22-634c-4a3c-9111-6ee752ccef9c)
**객체지향 설계는 객체 사이의 협력을 설계하고 그 후에 클래스의 내부 구조를 구현하는 순서로 진행한다.**  
협력에 필요한 행동을 먼저 결정하고, 행동에 적합한 객체를 나중에 선택하면 객체 사이의 협력이 설계된다.  
이렇게 선택된 행동을 구현하면서 필요한 데이터를 나중에 결정하면 클래스의 내부 구현이 완성된다.  
**책임 주도 설계(Responsibility-Driven Design) : 객체들의 협력 관계를 기반으로 애플리케이션을 설계하는 방법(객체가 수행할 책임을 기반으로 객체와 객체 사이의 협력을 설계하는 방식)**  

객체지향에서 런타임 구성 요소는 객체이고(클래스 기반의 객체지향 언어의 경우), 컴파일타임 구성 요소(코드의 단위)는 클래스이기 때문에 객체의 구조와 객체 사이의 협력 관계를 먼저 결정한 후에 클래스 내부와 클래스 사이의 관계를 설계해야 한다.  

오브젝트(257 페이지)  
의존성과 관련해서 다루어야 하는 또 다른 주제는 **런타임 의존성(run-time dependency)**과 **컴파일타임 의존성(compile-time dependency)**의 차이다. 먼저 여기에서 사용하는 런타임과 컴파일타임의 의미를 이해할 필요가 있다.  
런타임은 간단하다. 말 그대로 애플리케이션이 실행되는 시점을 가리킨다. 컴파일타임은 약간 미묘하다. 일반적으로 컴파일타임이란 작성된 코드를 컴파일하는 시점을 가리키지만 문맥에 따라서는 **코드 그 자체를 가리키기도 한다.** 컴파일 타임 의존성이 바로 이런 경우에 해당한다. 컴파일타임 의존성이라는 용어가 중요하게 생각하는 것은 시간이 아니라 우리가 작성한 코드의 구조이기 때문이다. 또한 동적 타입 언어의 경우에는 컴파일 타임이 존재하지 않기 때문에 컴파일 타임 의존성이라는 용어를 실제로 컴파일이 수행되는 시점으로 이해하면 의미가 모호해질 수 있다. **따라서 어딘가에서 컴파일타임이라는 용어를 보게된다면 그것이 정말 컴파일이 진행되는 시점을 가리키는 것인지 아니면 코드를 작성하는 시점을 가리키는 것인지를 파악하는 것이 중요하다.**  
객체지향 애플리케이션에서 **런타임**의 주인공은 **객체**다. 따라서 런타임 의존성이 다루는 주제는 객체 사이의 의존성이다. 반면에 **코드** 관점에서 주인공은 **클래스**다. 따라서 컴파일타임 의존성이 다루는 주제는 클래스 사이의 의존성이다.  

## 객체지향 설계 흐름
![스크린샷 2024-10-11 오후 3 14 41](https://github.com/user-attachments/assets/9dcddf3e-e70d-48f2-b299-1963f2bfbe76)
1. 하나의 객체를 설계하기 위해서는 먼저 설계를 위한 문맥이 필요하다. (객체가 다른 객체와 협력하기 위해 보내는 요청을 객체를 설계하기 위한 문맥으로 활용한다.)  
2. 요청을 처리하는데 필요한 행동(책임)을 결정한다.  
3. 책임을 결정 후 책임을 수행하는데 적합한 객체를 선택한다.  
4. 책임 구현(클래스와 메서드를 이용해서 구현)  
5. 책임을 구현하는데 필요한 데이터를 결정하고 클래스의 필드로 정의한다.  

## 책임이란
![협력에 참여하기 위해 객체가 수행하는 행동](https://github.com/user-attachments/assets/7bd5da37-b6ef-456c-a1e4-d932f823d75f)
**객체지향에서의 책임이란 협력에 참여하기 위해 한 객체가 다른 객체에게 요청에 대한 응답을 제공하는 행동이다.**  
위 그림에서 DiscountPolicy 객체는 할인 요금을 계산하는 책임을 수행하고 있고, DiscountCondition 객체는 할인 여부를 판단하는 책임을 수행하고 있다.  
<br>
<br>
![책임은 행동 관점](https://github.com/user-attachments/assets/a50e713a-0e59-42b9-9969-c413a87f3399)

하는 것의 범주 : 외부의 요청에 대응해서 객체를 생성하거나 계산을 수행하거나 다른 객체의 행동을 시작시키고 제어하고 조절하는 행동이 포함된다.  
아는 것의 범주 : 내부의 캡슐화된 상태를 알거나 협력할 객체에 관해 알거나 유도하거나 계산할 수 있는 어떤 것을 아는 행동이 포함된다.  

**책임은 행동과 관련이 있다는 사실이 중요하다.** 종종 아는 것과 관련된 책임을 내부에 해당하는 데이터를 저장해야 한다는 것으로 오해하는 사람이 있다.  
책임은 행동 관점이이기 때문에 어떤 것을 아는 책임을 할당받았다는 것은 해당 데이터를 저장해야 한다는 것이 아니라 **정보에 대해 대답(요청에 대한 응답)할 수 있어야 한다는 것을 의미한다.**  

책임이 중요한 이유 : 객체지향에서 책임이 중요한 이유는 객체의 구현이 아니라 객체 사이의 협력에 초점을 맞출 수 있도록 해주기 때문이다.  

![책임 주도 설계 살펴보기](https://github.com/user-attachments/assets/4351b64d-c160-434c-abf5-e8cbb1d9cedc)
1. 객체의 협력을 구하기 위해서는 애플리케이션이 외부에 제공해야 하는 기능을 파악해야 한다. (파악한 기능을 협력을 설계하기 위한 문맥으로 활용)  
2. 기능이 식별됐으면 이 기능을 시스템이 외부에 제공해야 하는 책임으로 간주한다.  
3. 외부에 제공해야 하는 시스템의 책임을 시스템 내부에 존재하는 객체의 책임으로 변환한다.  
4. 설계의 문맥은 시스템 외부에 제공할 기능에서 시스템 내부에 존재하는 객체사이의 협력으로 바뀌게 된다.  
5. 책임을 결정했으면 책임을 수행할 적합한 객체를 선택한다. **(적합한 객체를 선택하는 것은 위 과정 중 가장 어려운 일)**  
6. 객체가 책임을 수행하는 도중에 스스로 처리할 수 없는 로직이 식별될 경우 외부에 도움을 요청한다.
7. 이 요청이 새로운 책임으로 변환된다.  
8. 책임을 담당할 적절한 객체를 선택한다. (객체에게 요청을 전송하고 적합한 객체를 선택하는 과정을 반복)  

## GRASP(General Responsibility Assignment Software Pattern) 일반적인 책임 할당을 위한 소프트웨어 패턴
![9가지 GRASP 패턴](https://github.com/user-attachments/assets/c20b07ad-8490-4748-9375-7b5ca5bcca42)
![책임과 협력을 표현하기 위한 객체지향 설계 도구](https://github.com/user-attachments/assets/80f50d65-2f90-42f6-a4f2-3052b4048bf9)
![CRC는 객체 협력을 위한 설계 도구](https://github.com/user-attachments/assets/34304370-74b7-4d2e-9eba-654a27575170)
CRC(Candidate, Responsibility, Collaborate)는 켄트백과 워드 커닝엄이 객체지향 설계를 가르치기 위한 도구로 물리적인 인덱스 카드를 이용해서 책임을 기술할 수 있는 설계 도구이다.  
CRC카드는 클래스와 유사해 보이지만, 정적인 클래스가 아니라 런타임에 실제로 행동을 수행하는 동적인 객체를 나타내야한다.  

Candidate(후보, 역할) : 객체 또는 역할을 기입  
Responsibility(책임) : 객체가 수행할 책임을 기입  
Collaborator(협력자) : 협력할 다른 객체를 기입  

### 정보 전문가 패턴
![스크린샷 2024-10-11 오후 6 07 53](https://github.com/user-attachments/assets/593b2eb5-aab3-4b9a-8540-49098e87a6ad)
책임을 할당할 때 제일 먼저 살펴봐야 하는 가장 기본이 되는 패턴이다.  
어떤 책임을 객체에게 할당할 때 적용할 수 있는 가장 일반적인 원칙을 찾는 문제를 해결하기 위해 사용한다.  
책임을 수행하는데 필요한 정보를 가장 많이 알고있는 객체에 할당해야 한다.  

![정보는 데이터가 아니라 행동](https://github.com/user-attachments/assets/64645bc0-c4b5-4a07-b0b7-fcc5cc57807e)
여기에서 말하는 정보란 객체가 내부에 저정하고 있는 데이터를 의미하는 것이 아니라, 외부에 제겅하는 행동이라는 사실을 이해해야 한다.  
객체지향 관점에서는 객체가 내부에 해당 데이터를 저장하고 있지 않더라도 정보에 대한 질문에 답할 수 있다면, 해당 정보를 책임지고 있는 것으로 간주한다.  

**함께 일하는 사람들 중 대다수가 합리적이라고 동의하면 그게 답이 된다.**  
객체지향 설계의 목표는 완벽한 모델을 구축하는 것이 아니라 여러 사람이 동의할 수 있는 모델을 구축할 수 있다면 목표를 달성했다고 볼 수 있다.  

![스크린샷 2024-10-15 오후 7 52 50](https://github.com/user-attachments/assets/bc558b7c-a7c6-4695-bd67-5163d91516e3)
정보는 행동 관점이기 때문에 내부의 데이터가 다르더라도 외부에서 보이는 행동은 동일한 것이다.  
위 그림과 같이 **객체 내부의 데이터 저장 방식과 메서드의 수행 방식을 구현**이라 부르고, **외부에서 객체가 행동을 수행하도록 요청할 수 있는 메서드의 시그니처를 인터페이스**라고 부른다.  
객체가 수행할 책임만 동일하게 유지한다면 내부의 구현 방식을 바꾸더라도 외부에 영향을 미치지 않는다.  
책임만 잘 정의한다면 객체 내부의 구현은 언제라도 바꿀 수 있다. (객체가 수행할 행동 또는 책임이 내부 구현보다 훨씬 중요하다. = 인터페이스 설계의 중요성?)  
**행동을 먼저 결정한 후에 객체를 선택하고 데이터를 가장 마지막에 결정한 이유가 바로 이것 때문이다. 행동을 먼저 결정해서 외부의 객체가 인터페이스에 의존하도록 만들면 객체 내부의 구현을 변경하더라도 외부에 영향을 미치지 않을 수 있다.**  

![reserve(screening)](https://github.com/user-attachments/assets/db816e78-e0e3-4f20-8220-8c8d512c6d18)
객체는 스스로 책임을 수행하는 자율적인 존재이기 때문에 목적어를 주어로 바꾸면 능동적으로 그 행동을 수행하도록 만들 수 있다.  
책임을 할당한 후보가 혼동된다면, 책임에서 목적어를 찾은 다음 그 목적어에 책임을 할당해 보면 된다.  

### 창조자 패턴과 낮은 결합도 패턴  
![스크린샷 2024-10-21 오후 2 40 30](https://github.com/user-attachments/assets/fd708fbc-09d3-49a0-b010-ff8b676dd2d8)
창조자 패턴은 새로운 인스턴스를 생성하는 책임을 어떤 객체에게 할당할 지 결정해야 할 때 적용할 수 있다.  
1. 생성되는 객체를 포함(낮은 결합도).  
2. 참조하는 객체, 생성되는 객체를 기록하는 객체(낮은 결합도).  
3. 생성되는 객체를 긴밀하게 사용하는 객체(낮은 결합도).  
4. 생성되는 객체를 초기화하는데 필요한 정보를 알고 있는 객체(정보 전문가).

생성할 책임을 맡게 될 객체는 생성되는 객체와 밀접한 관계를 맺고 있는 객체라는 사실을 알 수 있다.  
  
  
![스크린샷 2024-10-21 오후 2 34 42](https://github.com/user-attachments/assets/0a2c565c-5b38-457f-aad8-8d5ce6333359)
창조자 패턴의 나머지 항목들은 생성되는 객체를 잘 알고 있는 객체에게 책임을 할당하라고 이야기하고 있다.  

  
![스크린샷 2024-10-21 오후 2 36 15](https://github.com/user-attachments/assets/f54ddea4-98f3-4989-ab09-998f73381e0b)
**결합도**란 어느 한 객체가 다른 객체에 의존하는 정도를 의미한다.  
책임을 할당할 때는 가급적이면 전체적으로 결합도가 낮아지는 방향으로 책임을 할당해야 한다.  
낮은 결합도 패턴은 책임을 할당할 후보들 중에서 전체적으로 설계의 결합도를 낮출 수 있는 후배에게 책임을 할당하라고 조언한다.  
**결합도를 낮출 수 있는 후보에게 책임을 할당하면 수정하기 용이하고 재사용성이 높은 설계를 만들 수 있다.**  
  
  
### 높은 응집도 패턴
![스크린샷 2024-10-21 오후 3 08 18](https://github.com/user-attachments/assets/fd9cffb5-b3d5-4008-9e35-271119cc13bf)
GRASP 패턴에서는 낮은 결합도를 유지하고 변경에 따른 영향을 줄이면서 재사용성을 향상시키기 위해서는 높은 응집도를 유지하도록 책임을 할당해야 한다고 조언한다.  

  
![스크린샷 2024-10-21 오후 3 11 03](https://github.com/user-attachments/assets/4fcc39b1-43b9-419c-ad8f-4d1fd0bdf795)
**높은 응집도란 서로 밀접한 관련성을 가진 책임들만 같은 객체에 할당해야 한다.**  
객체지향에서는 유사한 책임들이 함께 모여 있을 경우에는 응집도가 높다고 이야기하고 이질적인 책임들이 함께 모여 있을 경우에는 응집도가 낮다고 이야기한다.  
이렇게 연관성 높은 책임들을 객체에 할당하고 연관성이 낮은 책임들을 다른 객체로 이동시켜면 하나의 객체가 너무 많은 일을 하게 되는 일을 방지할 수 있다.  
  
  
![스크린샷 2024-10-21 오후 3 21 21](https://github.com/user-attachments/assets/b7925514-b4a7-4c8a-89c3-9260e3d26211)
서로 연관성이 적은 책임이 하나의 객체 안에 모여 있으면(서로 상관없는 데이터와 로직) 코드를 읽을 때 수정할 부분을 찾기가 어려워진다.  
서로 다른 책임이 하나의 코드 안에 함께 공존하기 때문에 어떤 책임을 부연한 코드를 수정하면 이 책임과는 아무런 상관이 없는 다른 코드가 영향을 받을 가능성도 높아진다.  
**따라서 응집도가 낮으면 코드를 이해하기도 어렵고 수정으로 인한 버그가 발생할 활률도 높아진다.**

높은 응집도 패턴은 책임을 할당할 때 낮은 결합도 패턴과 함께 설계의 품질을 평가하기 위한 기준으로 사용된다.  
**두 객체 중에 어떤 객체에게 책임을 할당할지 판단하기 어렵다면 설계 전체적으로 응집도를 높일 수 있는 객체에게 책임을 할당하는 것이 좋다.**  

설계의 목적은 코드를 수정하기 쉽게 만드는 것이다.  
**수정하기 쉬운 코드를 얻기 위해서는 협력을 구성하는 객체의 응집도는 높이고 객체들 사이의 결합도는 낮춰야 한다.**  

설계를 하는 매 순간마다 여러 가지 대안 중에서 하나를 선택해야 한다.(트레이드 오프)  
설계를 배우는 과정은 다양한 상황에서 결정을 내리는데 필요한 여러 가지 판단 기준을 익히는 것과 같다.  
  
![스크린샷 2024-10-21 오후 3 34 13](https://github.com/user-attachments/assets/998b3c5f-7567-4d56-a37a-448bc096c28e)
DiscountPolicy 클래스의 응집도가 낮기 때문에 할인 정책이 추가될 때 마다 Movie 클래스도 변경이 발생한다.  
  
![스크린샷 2024-10-21 오후 3 39 14](https://github.com/user-attachments/assets/48a72993-b952-4652-b658-113027058ee1)
DiscountPolicy 클래스 안에는 서로 상관없는 메서드들이 공존하고 있기 떄문에 Movie 클래스는 이 중에서 적합한 메서드를 호출하기 위해 조건문을 추가했다.  
Movie 클래스는 할인 정책을 책임지지 않지만 응집도가 낮은 DiscountPolicy와 협력한다는 이유만으로 할인 정책을 추가할 때 함께 수정되고 있다.  
이러한 문제가 발생하는 이유는 Movie 클래스가 DiscountPolicy와 강하게 결합되어 있기 때문이다.
  
  
### 다형성 패턴
![스크린샷 2024-10-21 오후 3 47 14](https://github.com/user-attachments/assets/26180ec8-a7e8-4e23-a4a8-90d7601ad84d)
타입을 기반으로 유사하지만 서로 다르게 핼동하는 객체들이 존재할 때 다형성 패턴을 적용한다.  
  
![스크린샷 2024-10-21 오후 3 48 46](https://github.com/user-attachments/assets/a6c44124-6202-4221-a1ac-d1127db1c29e)
행동을 분기하기 위해(시스템의 행동을 확장) 조건문을 사용하면 새로운 행동을 추가하기 위해 조건문을 수정해야 한다.  
  
![스크린샷 2024-10-21 오후 3 52 47](https://github.com/user-attachments/assets/e02ff2bc-65b3-4fd3-a604-677aec30206d)
조건문을 사용하지 않고 변하는 행동을 처리하고 싶을 때 다형성 패턴을 사용한다.  

![스크린샷 2024-10-21 오후 3 54 29](https://github.com/user-attachments/assets/9dc1bb0c-23db-4815-a248-4a5a82b71230)
Movie 클래스 입장에서는 할인 정책을 사용할 때 여러 개 중에서 하나를 선택해야 한다.  
이러한 상황을 Movie 클래스 입장에서는 변하는 행동으로 보여진다.  
다형성 패턴에 따르면 이렇게 변하는 행동들은 하나의 객체 안에 함께 두면 안 되고 각각의 행동을 수행하는 독립적인 타입으로 분리해야 한다.  
다시 말해, 유사해 보이지만 서로 다르게 동작하는 책임이 하나의 후보안에 뭉쳐 있다면 타입을 분리한 후에 서로 다른 책임은 서로 다른 타입의 객체에게 할당해야 한다.  
따라서 금액 할인 정책이라는 좀 더 특화된 타입(비율 할인 클래스, 금액 할인 클래스로 분리)의 할인 금액을 계산하는 책임을 할당해야 한다.  
  
![스크린샷 2024-10-21 오후 4 06 22](https://github.com/user-attachments/assets/fed37be0-a963-4d25-a9b4-90e2ba38d026)
![스크린샷 2024-10-21 오후 4 37 34](https://github.com/user-attachments/assets/bc1fde8d-d246-4b89-ba5f-86b44a9f2fe4)
독립적인 타입으로 분리하였지만, 여전히 조건문을 통해 할인 금액을 가져오고 있고 다른 정책이 추가될 때 마다 Movie 클래스도 변경이 발생하므로 여전히 결합도가 높다고 볼 수 있다.  
  
![스크린샷 2024-10-21 오후 4 39 22](https://github.com/user-attachments/assets/5b8cccd7-6486-4fbe-b464-5160fae98f06)
객체지향에서 한 객체가 다른 객체와 협력하기 위해 보내는 요청을 메시지라고 부른다.
메시지는 객체가 협력을 위해 사용할 수 있는 유일한 의사소통 수단이다.

### 변경 보호 패턴
![스크린샷 2024-10-21 오후 4 43 55](https://github.com/user-attachments/assets/f7ec8dc3-e0c6-4080-ba05-90f46bf51440)
변경 보호 패턴은 할인 정책의 종류처럼 불안정하게 변하는 요소에 강하게 결합되기 때문에 수정하기 어려운 코드가 만들어지는 문제를 해결하기 위한 패턴이다.  
변경 보호 패턴을 적용해서 결합도를 낮추기 위해서는 변하는 부분을 식별하고 변하는 부분 주변에 안정적인 인터페이스나 추상화를 도입해야 한다.  

![스크린샷 2024-10-21 오후 4 46 38](https://github.com/user-attachments/assets/3ff88b1d-d146-4175-8447-1105515be27f)
**다형성이란 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행하는 행동이 달라지는 능력이다.**  
변화하는 대상인 비율 할인 정책과 금액 할인 정책 타입 주변에 할인 정책이라는 추상화를 추가한다.  
Movie 클래스에서는 추가한 인터페이스에게만 의존하도록 한다.  

![스크린샷 2024-10-21 오후 4 50 59](https://github.com/user-attachments/assets/a14f3759-9f5d-493e-a55e-68e26b71ce5e)
**구체적인 타입들로 대체 가능한 추상화를 역할이라고 부른다.**
만약 한 종류의 객체만 역할을 대체한다면 객체와 역할은 동일하다고 볼 수 있다.  
하지만 여러 종류의 객체가 대체할 수 있다면 역할은 객체와 동일하지 않으며 이 경우 역할은 객체가 대체할 수 있는 추상화를 의미한다.  

![스크린샷 2024-10-21 오후 4 54 11](https://github.com/user-attachments/assets/291fd4f6-aeba-4b42-b150-bca3491e8585)
협력 : 한 객체가 다른 객체에게 메시지를 전송해서 도움을 요청하고 응답을 받는 과정이다.  
책임 : 객체가 다른 객체와 협력하기 위해 알아야 하거나 행동해야 하는 것을 의미한다.  
역할 : 협력 안에서 책임을 수행하는 대상이다. (객체가 하나일 땐 역할 = 객체, 여러개일 땐 역할은 추상화)  
**역할, 책임, 협력이 책임 주도 설계를 구성하는 핵심적인 요소가 된다.**  

![스크린샷 2024-10-21 오후 5 04 08](https://github.com/user-attachments/assets/1b6d3226-9ef0-4bf2-b069-ee7cd8c4354a)
![스크린샷 2024-10-21 오후 5 02 50](https://github.com/user-attachments/assets/fbe02e61-6a89-4e1b-9ce0-6255fbf0b511)
DiscountPolicy 입장에서도 여러 개의 할인 조건 사용하기 때문에 결합도가 높고, 변경에 취약하다.  
따라서, 다형성 패턴과 변경 보호 패턴을 조합해서 결합도를 낮출 필요가 있다.  
먼저 다형성 패턴을 이용해서 다형적인 메시지로 요청을 통합한다.  
그후에 변경 보호 패턴을 이용해서 할인조건이라는 안정적인 추상화를 추가하고, 할인 정책이 추상화에 의존하도록 수정한다.  
이렇게 할 경우 결합도가 낮아졌기 떄문에 새로운 할인 조건을 추가하더라도 협력하는 할인정책에는 영향을 미치지 않는다.  









