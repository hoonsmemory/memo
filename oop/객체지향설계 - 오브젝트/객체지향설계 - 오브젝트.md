## 절차적인 설계

![객체지향 - 오브젝트](images/객체지향%20-%20오브젝트.png)
![객체지향 - 오브젝트-1](images/객체지향%20-%20오브젝트-1.png)
![객체지향 - 오브젝트-2](images/객체지향%20-%20오브젝트-2.png)

절차적인 코드는 하나의 메서드(reserveScreening)안에 실행 순서대로 배치되고 모든 제어 흐름을 갖는다.(중앙집중식 제어 스타일)
하나의 메서드 안에서 여러 로직(도메인)을 실행하므로 단일 책임 원칙을 위배하고, 변경이 발생하면 변경할 클래스뿐만 아니라 여러 곳의 코드를 수정해줘야 한다.

![객체지향 - 오브젝트-3](images/객체지향%20-%20오브젝트-3.png)

절차적인 방식의 가장 큰 문제점은 **데이터를 구현한 코드의 수정에 취약하다는 점**이다.

![객체지향 - 오브젝트-4](images/객체지향%20-%20오브젝트-4.png)

![객체지향 - 오브젝트-5](images/객체지향%20-%20오브젝트-5.png)

절차적인 방식에서는 여러 프로세스가 데이터를 공유하기 때문에 데이터가 바뀌면 데이터에 의존하는 하나 이상의 프로세스가 동시에 수정되는 문제가 발생한다.
조합 조건을 추가하기 위해 데이터인 DiscountCondition 클래스를 수정했고, 그 영향으로 데이터를 사용하는 프로세스인 ReservationService 클래스가 함께 수정되었다.
이렇게 **데이터를 수정할 때 프로세스도 함께 수정해야 한다는 점이 절차적인 설계가 가지는 전형적인 문제다.**

## 의존성

![객체지향 - 오브젝트-6](images/객체지향%20-%20오브젝트-6.png)

그림에서 보는 것처럼 A와 B라는 모듈이 있을 때 A가 B를 사용한다면 A가 B에 의존한다.
**의존성**이라는 용어 안에는 **변경**이라는 개념이 포함되어 있다는 사실이 매우 중요하다.
즉 A가 B에 의존한다는 말에는 B가 변경될 때 A도 함께 변경될 가능성(다양한 의존성이 존재하기 때문에 항상 변경되지는 않음)이 있다는 의미가 포함되어있다.

![객체지향 - 오브젝트-7](images/객체지향%20-%20오브젝트-7.png)

위 그림처럼 외부 클래스의 클래스명이 변경되거나 내부 구조가 변경되거나 메서드 시그니처가 변경되는 등 외존하고 있는 객체때문에 변경이 발생할 수 있다.

## 의존성의 방향과 변경의 방향

![객체지향 - 오브젝트-8](images/객체지향%20-%20오브젝트-8.png)

![객체지향 - 오브젝트-9](images/객체지향%20-%20오브젝트-9.png)

프로세스는 데이터에 의존하고 변경의 방향은 의존성의 방향과 반대가 된다.
변경과 의존성이 서로 관련이 있기 때문에 결과적으로 **변경하기 쉬운 설계를 만들기 위해서는 의존성을 통제해야 한다.**


## 추측에 의한 설계 전략(Design-By-Guessing Strategy)

![객체지향 - 오브젝트-10](images/객체지향%20-%20오브젝트-10.png)**
**
![객체지향 - 오브젝트-11](images/객체지향%20-%20오브젝트-11.png)

문맥과 무관하게 어떤 상황에서도 데이터를 사용 가능하도록 내부의 데이터를 그대로 드러내는 설계 방식을 추측에 의한 설계전략이라고 한다.
변경하기 쉬운 설계를 만들기 위해서는 데이터 변경으로 인한 파급효과를 막는 것이 핵심이다.

**☞절차적인 방식으로 부여하는 코드는 데이터를 수정할 때 프로세스가 함께 수정된다는 단점을 가지고 있다.**

## 분리되어있는 데이터와 프로세스의 문제 해결

![객체지향 - 오브젝트-12](images/객체지향%20-%20오브젝트-12.png)

![객체지향 - 오브젝트-13](images/객체지향%20-%20오브젝트-13.png)

문제의 근본 원인이 프로세스와 데이터를 별도의 모듈로 분리했기 때문이라면, 이 문제를 해결할 수 있는 가장 좋은 방법은 데이터와 프로세스를 하나의 모듈로 합치는 것이다.
즉, 데이터를 변경할 때 다른 모듈 안에 포함된 프로세스가 함께 변경되는 상황이 문제이기 때문에 데이터와 프로세스를 동일한 모듈 안에 위치시켜서 하나의 모듈 안에서만 변경이 발생하도록 개선하면 코드를 수정하기가 쉬워질 것이다.

**데이터와 프로세스의 통합이 객체지향의 바탕을 이루는 가장 기본적인 개념이다.**

## 리팩토링

![객체지향 - 오브젝트-14](images/객체지향%20-%20오브젝트-14.png)

![객체지향 - 오브젝트-15](images/객체지향%20-%20오브젝트-15.png)

## 리팩토링-1. 책임의 이동

![객체지향 - 오브젝트-16](images/객체지향%20-%20오브젝트-16.png)

![객체지향 - 오브젝트-17](images/객체지향%20-%20오브젝트-17.png)

![객체지향 - 오브젝트-18](images/객체지향%20-%20오브젝트-18.png)

데이터를 사용하는 로직을 데이터를 보유한 클래스 쪽으로 옮기면 데이터가 수정될 때 변경의 영향 범위를 데이터 클래스 내부로 제한할 수 있게 된다.
책임을 데이터로 이동하여 DiscountCondition이 변경될 때 ReservationService에 영향이 없도록 한다.

## 데이터와 객체의 차이

![객체지향 - 오브젝트-19](images/객체지향%20-%20오브젝트-19.png)

![객체지향 - 오브젝트-20](images/객체지향%20-%20오브젝트-20.png)

![객체지향 - 오브젝트-21](images/객체지향%20-%20오브젝트-21.png)

**로직의 특성에 따라서 클래스의 인스턴스는 데이터가 될 수도 있고 객체가 될 수도 있다.**
로직이 클래스의 인스턴스를 수동적인 존재로 만든다면, 이 클래스의 인스턴스는 데이터가 된다. (단순히 데이터를 외부에 제공하고 외부의 판단하고 결정에 전적으로 의존)
로직이 클래스의 인스턴스를 능동적인 존재로 만든다면, 이 클래스의 인스턴스는 객체가 된다. (자기 자신의 상태를 직접 관리하고 스르로 판단하고 결정하는 자율적인 존재)

인스턴스가 다른 객체의 판단에 의존하거나 세세한 의사결정을 외부에 의존한다면 클래스로 구현됐다고 하더라도 그 인스턴스는 데이터라고 불러야 한다.
**자기 스스로의 원칙에 따라 일을 하거나 자기 자신을 통제할 수 있는 객체를 설계하는 것이 객체지향의 기본 철학이다.**

## 리팩토링-2. 의존성 줄이기

![객체지향 - 오브젝트-22](images/객체지향%20-%20오브젝트-22.png)

![객체지향 - 오브젝트-23](images/객체지향%20-%20오브젝트-23.png)

![객체지향 - 오브젝트-24](images/객체지향%20-%20오브젝트-24.png)

![객체지향 - 오브젝트-25](images/객체지향%20-%20오브젝트-25.png)

![객체지향 - 오브젝트-26](images/객체지향%20-%20오브젝트-26.png)

기존 ReservationService에서는 DiscountPolicy와 DiscountCondition 두 개의 클래스에 의존하고 있었다.
객체지향 설계에서는 의존성을 최대한 줄여야 한다.
따라서 ReservationService -> DiscountPolicy -> DiscountCondition 구조로 변경이 필요하다. (ReservationService에서 호출하고 있던 findDiscountCondition 메서드를 DiscountPolicy로 옮겨 의존성을 낮춘다.)

## 객체지향 설계 원칙

결과적으로 객체지향 설계는 요구사항이 변경될 때 코드를 보다 쉽고 안전하게 수정하기 위함이다.

#### 1. 다른 객체의 요청을 처리하기 위해 필요한 행동(협력에 필요한 행동)을 먼저 결정하고, 행동에 적합한 객체를 나중에 선택하라

![객체지향 - 오브젝트-27](images/객체지향%20-%20오브젝트-27.png)

![객체지향 - 오브젝트-28](images/객체지향%20-%20오브젝트-28.png)

![객체지향 - 오브젝트-29](images/객체지향%20-%20오브젝트-29.png)

객체의 행동은 고립된 상태가 아닌 다른 객체와의 협력이라는 문맥 안에서 결정해야 한다.
클라이언트의 요청을 먼저 결정한 후에 이 요청을 처리할 객체를 나중에 선택해야 한다.

위 그림처럼 "할인 금액을 계산하라" 라는 요청이 먼저 존재하고 이 요청을 처리하기에 적합한 객체(DiscountPolicy)를 나중에 선택해야 한다. **(행동이 객체를 결정)**
**행동을 먼저 결정하고 객체를 나중에 선택하는 방식으로 설계하면 ,변경에 유연하고 필요한 요소만 포함하는 클래스를 얻을 수 있다.**
행동이 결정되면 앞에서 살펴본 원칙에 따라 행동을 부연하는데 적합한 데이터를 선택하면 된다.
이렇게 데이터를 나중에 선택하면, 데이터가 변경되더라도 외부에 영향이 미치지 않는다.

**협력 : 객체가 다른 객체에게 도움을 얻기 위해 요청하고 응답하는 과정**

#### 2. 객체의 행동을 먼저 구현하고, 행동에 필요한 데이터를 나중에 선택하라

![객체지향 - 오브젝트-30](images/객체지향%20-%20오브젝트-30.png)

![객체지향 - 오브젝트-31](images/객체지향%20-%20오브젝트-31.png)

절차적인 설계에서는 데이터(DiscountPolicy)와 프로세스(ReservationService)를 독립적인 단위로 나눠서 설계를 한다.
사용될 목록을 고려하지 않고 데이터를 설계하기 때문에 모든 경우에 사용 가능하도록 Getter, Setter를 추가한다.
이런 추측에 의한 설계 전략이 나쁜 이유는 겉으로 보기에는 필드를 캡슐화한것처럼 보이지만 실제로는 Getter, Setter를 통해 클래스 내부를 그대로 드러내고 있기 때문이다.
데이터의 구조가 프로세스에 그대로 노출되기 때문에 데이터의 내부 구조가 수정되면 데이터를 사용하는 프로세스도 함께 수정될 수밖에 없다.
**따라서, 변경으로 인한 문제를 해결하기 위해서는 데이터와 프로세스를 하나의 모듈 안에 함께 작성해야한다. (책임의 이동)**

![객체지향 - 오브젝트-32](images/객체지향%20-%20오브젝트-32.png)

설계를 개선하기 전에는 내부의 데이터 구조에 의존했지만, 설계를 개선한 후에는 외부에 공개하는 메서드에 의존한다.
**데이터를 자유롭게 수정하기 위해서는 외부 객체가 행동에 의존하도록 만들어야 한다.**
외부 객체가 데이터에 의존하지 않도록 만드는 가장 좋은 방법은 데이터를 결정하기 전에 먼저 행동부터 결정하는 것이다.
데이터가 없는 상태에서 행동을 먼저 결정하면 외부에서는 데이터에 대해서는 알 수 없기 때문에 행동에 의존할 수 밖에 없다.

![객체지향 - 오브젝트-33](images/객체지향%20-%20오브젝트-33.png)

![객체지향 - 오브젝트-34](images/객체지향%20-%20오브젝트-34.png)

![객체지향 - 오브젝트-35](images/객체지향%20-%20오브젝트-35.png)

외부 객체의 요청에 응답하기 위한 메서드(행동)를 먼저 구현 후 메서드에 필요한 데이터를 추가한다.

## 객체지향 설계 순서

![객체지향 - 오브젝트-36](images/객체지향%20-%20오브젝트-36.png)

![객체지향 - 오브젝트-37](images/객체지향%20-%20오브젝트-37.png)

![객체지향 - 오브젝트-38](images/객체지향%20-%20오브젝트-38.png)

**객체지향 설계는 객체 사이의 협력을 설계하고 그 후에 클래스의 내부 구조를 구현하는 순서로 진행한다.**
협력에 필요한 행동을 먼저 결정하고, 행동에 적합한 객체를 나중에 선택하면 객체 사이의 협력이 설계된다.
이렇게 선택된 행동을 구현하면서 필요한 데이터를 나중에 결정하면 클래스의 내부 구현이 완성된다.
**책임 주도 설계(Responsibility-Driven Design) : 객체들의 협력 관계를 기반으로 애플리케이션을 설계하는 방법(객체가 수행할 책임을 기반으로 객체와 객체 사이의 협력을 설계하는 방식)**

객체지향에서 런타임 구성 요소는 객체이고(클래스 기반의 객체지향 언어의 경우), 컴파일타임 구성 요소(코드의 단위)는 클래스이기 때문에 객체의 구조와 객체 사이의 협력 관계를 먼저 결정한 후에 클래스 내부와 클래스 사이의 관계를 설계해야 한다.

오브젝트(257 페이지)
의존성과 관련해서 다루어야 하는 또 다른 주제는 **런타임 의존성(run-time dependency)**과 **컴파일타임 의존성(compile-time dependency)**의 차이다. 먼저 여기에서 사용하는 런타임과 컴파일타임의 의미를 이해할 필요가 있다.
런타임은 간단하다. 말 그대로 애플리케이션이 실행되는 시점을 가리킨다. 컴파일타임은 약간 미묘하다. 일반적으로 컴파일타임이란 작성된 코드를 컴파일하는 시점을 가리키지만 문맥에 따라서는 **코드 그 자체를 가리키기도 한다.** 컴파일 타임 의존성이 바로 이런 경우에 해당한다. 컴파일타임 의존성이라는 용어가 중요하게 생각하는 것은 시간이 아니라 우리가 작성한 코드의 구조이기 때문이다. 또한 동적 타입 언어의 경우에는 컴파일 타임이 존재하지 않기 때문에 컴파일 타임 의존성이라는 용어를 실제로 컴파일이 수행되는 시점으로 이해하면 의미가 모호해질 수 있다. **따라서 어딘가에서 컴파일타임이라는 용어를 보게된다면 그것이 정말 컴파일이 진행되는 시점을 가리키는 것인지 아니면 코드를 작성하는 시점을 가리키는 것인지를 파악하는 것이 중요하다.**
객체지향 애플리케이션에서 **런타임**의 주인공은 **객체**다. 따라서 런타임 의존성이 다루는 주제는 객체 사이의 의존성이다. 반면에 **코드** 관점에서 주인공은 **클래스**다. 따라서 컴파일타임 의존성이 다루는 주제는 클래스 사이의 의존성이다.

## 객체지향 설계 흐름

![객체지향 - 오브젝트-39](images/객체지향%20-%20오브젝트-39.png)

1. 하나의 객체를 설계하기 위해서는 먼저 설계를 위한 문맥이 필요하다. (객체가 다른 객체와 협력하기 위해 보내는 요청을 객체를 설계하기 위한 문맥으로 활용한다.)
2. 요청을 처리하는데 필요한 행동(책임)을 결정한다.
3. 책임을 결정 후 책임을 수행하는데 적합한 객체를 선택한다.
4. 책임 구현(클래스와 메서드를 이용해서 구현)
5. 책임을 구현하는데 필요한 데이터를 결정하고 클래스의 필드로 정의한다.

## 책임이란

![객체지향 - 오브젝트-40](images/객체지향%20-%20오브젝트-40.png)

**객체지향에서의 책임이란 협력에 참여하기 위해 한 객체가 다른 객체에게 요청에 대한 응답을 제공하는 행동이다.**
위 그림에서 DiscountPolicy 객체는 할인 요금을 계산하는 책임을 수행하고 있고, DiscountCondition 객체는 할인 여부를 판단하는 책임을 수행하고 있다.

![객체지향 - 오브젝트-41](images/객체지향%20-%20오브젝트-41.png)**
**

하는 것의 범주 : 외부의 요청에 대응해서 객체를 생성하거나 계산을 수행하거나 다른 객체의 행동을 시작시키고 제어하고 조절하는 행동이 포함된다.
아는 것의 범주 : 내부의 캡슐화된 상태를 알거나 협력할 객체에 관해 알거나 유도하거나 계산할 수 있는 어떤 것을 아는 행동이 포함된다.

**책임은 행동과 관련이 있다는 사실이 중요하다.** 종종 아는 것과 관련된 책임을 내부에 해당하는 데이터를 저장해야 한다는 것으로 오해하는 사람이 있다.
책임은 행동 관점이이기 때문에 어떤 것을 아는 책임을 할당받았다는 것은 해당 데이터를 저장해야 한다는 것이 아니라 **정보에 대해 대답(요청에 대한 응답)할 수 있어야 한다는 것을 의미한다.**

책임이 중요한 이유 : 객체지향에서 책임이 중요한 이유는 객체의 구현이 아니라 객체 사이의 협력에 초점을 맞출 수 있도록 해주기 때문이다.

![객체지향 - 오브젝트-42](images/객체지향%20-%20오브젝트-42.png)

1. 객체의 협력을 구하기 위해서는 애플리케이션이 외부에 제공해야 하는 기능을 파악해야 한다. (파악한 기능을 협력을 설계하기 위한 문맥으로 활용)
2. 기능이 식별됐으면 이 기능을 시스템이 외부에 제공해야 하는 책임으로 간주한다.
3. 외부에 제공해야 하는 시스템의 책임을 시스템 내부에 존재하는 객체의 책임으로 변환한다.
4. 설계의 문맥은 시스템 외부에 제공할 기능에서 시스템 내부에 존재하는 객체사이의 협력으로 바뀌게 된다.
5. 책임을 결정했으면 책임을 수행할 적합한 객체를 선택한다. **(적합한 객체를 선택하는 것은 위 과정 중 가장 어려운 일)**
6. 객체가 책임을 수행하는 도중에 스스로 처리할 수 없는 로직이 식별될 경우 외부에 도움을 요청한다.
7. 이 요청이 새로운 책임으로 변환된다.
8. 책임을 담당할 적절한 객체를 선택한다. (객체에게 요청을 전송하고 적합한 객체를 선택하는 과정을 반복)

## GRASP(General Responsibility Assignment Software Pattern) 일반적인 책임 할당을 위한 소프트웨어 패턴

![객체지향 - 오브젝트-43](images/객체지향%20-%20오브젝트-43.png)

![객체지향 - 오브젝트-44](images/객체지향%20-%20오브젝트-44.png)

![객체지향 - 오브젝트-45](images/객체지향%20-%20오브젝트-45.png)

CRC(Candidate, Responsibility, Collaborate)는 켄트백과 워드 커닝엄이 객체지향 설계를 가르치기 위한 도구로 물리적인 인덱스 카드를 이용해서 책임을 기술할 수 있는 설계 도구이다.
CRC카드는 클래스와 유사해 보이지만, 정적인 클래스가 아니라 런타임에 실제로 행동을 수행하는 동적인 객체를 나타내야한다.

Candidate(후보, 역할) : 객체 또는 역할을 기입

Responsibility(책임) : 객체가 수행할 책임을 기입

Collaborator(협력자) : 협력할 다른 객체를 기입

### 정보 전문가 패턴

![객체지향 - 오브젝트-46](images/객체지향%20-%20오브젝트-46.png)

책임을 할당할 때 제일 먼저 살펴봐야 하는 가장 기본이 되는 패턴이다.
어떤 책임을 객체에게 할당할 때 적용할 수 있는 가장 일반적인 원칙을 찾는 문제를 해결하기 위해 사용한다.
책임을 수행하는데 필요한 정보를 가장 많이 알고있는 객체에 할당해야 한다.

![정보는 데이터가 아니라 행동.png](..%2F..%2F..%2F..%2F..%2F..%2F..%2FLibrary%2FGroup%20Containers%2Fgroup.com.apple.notes%2Ftmp%2FHardLinkURLTemp%2FF86CF871-6852-4312-AB53-8227D5E8CD04%2F-62135769600%2F%EC%A0%95%EB%B3%B4%EB%8A%94%20%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B0%80%20%EC%95%84%EB%8B%88%EB%9D%BC%20%ED%96%89%EB%8F%99.png)
여기에서 말하는 정보란 객체가 내부에 저정하고 있는 데이터를 의미하는 것이 아니라, 외부에 제겅하는 행동이라는 사실을 이해해야 한다.
객체지향 관점에서는 객체가 내부에 해당 데이터를 저장하고 있지 않더라도 정보에 대한 질문에 답할 수 있다면, 해당 정보를 책임지고 있는 것으로 간주한다.

**함께 일하는 사람들 중 대다수가 합리적이라고 동의하면 그게 답이 된다.**
객체지향 설계의 목표는 완벽한 모델을 구축하는 것이 아니라 여러 사람이 동의할 수 있는 모델을 구축할 수 있다면 목표를 달성했다고 볼 수 있다.

![스크린샷 2024-10-15 오후 7.52.50.png](..%2F..%2F..%2F..%2F..%2F..%2F..%2FLibrary%2FGroup%20Containers%2Fgroup.com.apple.notes%2FAccounts%2F2F46084E-883F-4CD0-BE12-33EDAE25E806%2FMedia%2F75D31A21-8943-450E-A520-A7CA9B3A9522%2F%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202024-10-15%20%EC%98%A4%ED%9B%84%207.52.50.png)
정보는 행동 관점이기 때문에 내부의 데이터가 다르더라도 외부에서 보이는 행동은 동일한 것이다.
위 그림과 같이 **객체 내부의 데이터 저장 방식과 메서드의 수행 방식을 구현**이라 부르고, **외부에서 객체가 행동을 수행하도록 요청할 수 있는 메서드의 시그니처를 인터페이스**라고 부른다.
객체가 수행할 책임만 동일하게 유지한다면 내부의 구현 방식을 바꾸더라도 외부에 영향을 미치지 않는다.
책임만 잘 정의한다면 객체 내부의 구현은 언제라도 바꿀 수 있다. (객체가 수행할 행동 또는 책임이 내부 구현보다 훨씬 중요하다. = 인터페이스 설계의 중요성?)
**행동을 먼저 결정한 후에 객체를 선택하고 데이터를 가장 마지막에 결정한 이유가 바로 이것 때문이다. 행동을 먼저 결정해서 외부의 객체가 인터페이스에 의존하도록 만들면 객체 내부의 구현을 변경하더라도 외부에 영향을 미치지 않을 수 있다.**

![reserve(screening).png](..%2F..%2F..%2F..%2F..%2F..%2F..%2FLibrary%2FGroup%20Containers%2Fgroup.com.apple.notes%2Ftmp%2FHardLinkURLTemp%2FF73EF49F-5DEE-4609-B189-508EBF2E018E%2F-62135769600%2Freserve%28screening%29.png)
객체는 스스로 책임을 수행하는 자율적인 존재이기 때문에 목적어를 주어로 바꾸면 능동적으로 그 행동을 수행하도록 만들 수 있다.
책임을 할당한 후보가 혼동된다면, 책임에서 목적어를 찾은 다음 그 목적어에 책임을 할당해 보면 된다.
