## 전술적 설계
**설계 방법 4가지**
* 트랜잭션 스크립트 패턴(일반적인 컨트롤러, 서비스(도메인 로직을 서비스에 구현), 리파지토리) 
* 액티브 래코드패턴
* 도메인 모델 패턴
* 애그리거트 패턴
<br>

### 설계 결정 방법
<img width="908" alt="스크린샷 2024-11-26 오후 3 53 56" src="https://github.com/user-attachments/assets/ee8c696e-fb17-4c3e-9c7c-a1c79ee70ecf">   


* Biz Logic 간단함 --> 지원, 일반 --> Transaction Script, Active Record  
    * 단순한 자료 구조 --> Transaction Script  
    * 복잡한 자료구조 --> Active Record  
* Biz Logic 복잡 --> 핵심 --> Domain Model  
    * 금전 또는 통화의 트랜잭션 추적, 일관된 감사 로그 , 동작에 따른 심층적 분석 요구 --> Event Sourcing   
  
반드시 애그리거트 패턴을 따를 필요는 없다.  
개발 환경을 고려해서 적절한 선택을 하는 것이 중요하다.  
<br>

### Aggregate Pattern
Aggregate Pattern은 도메인 주도 설계(DDD)에서 데이터와 비즈니스 로직의 일관성을 유지하기 위해 관련 객체를 묶는 단위를 정의하는 설계 패턴이다. 
Aggregate는 단순히 객체를 묶는 개념이 아니라, 트랜잭션과 변경 경계를 명확히 하여 시스템의 안정성과 유연성을 보장하는 데 초점이 맞춰져 있다.  
하지만, Aggregate를 과도하게 작거나 크게 설계하면 성능 저하나 관리 복잡성이 증가할 수 있으므로, 비즈니스 요구사항을 기반으로 적절한 크기와 경계를 설정하는 것이 중요하다.  

  
**Aggregate의 구성 요소**
1. Aggregate
    * Aggregate는 서로 연관된 엔티티(Entity)와 밸류 오브젝트(Value Object)를 그룹화하여, 하나의 일관된 작업 단위로 처리한다.
    * Aggregate는 도메인의 특정 비즈니스 개념을 표현한다.
    * 예: "주문(Order)" Aggregate는 주문 정보와 관련된 항목(예: 주문 항목, 배송 주소 등)을 모두 포함.
2. Aggregate Root
    * Aggregate의 중심이 되는 객체로, 외부에서 Aggregate에 접근할 때 반드시 Root를 통해야 한다.
    * Aggregate Root는 Aggregate 내부의 일관성을 책임지고, 상태 변경을 관리한다.
    * 예: "주문(Order)" Aggregate의 Root는 "주문" 객체이며, 외부에서 직접 "주문 항목"이나 "배송 주소"에 접근할 수 없다.
3. Entity
    * 고유 식별자를 가진 객체로, Aggregate 내부의 구성 요소가 될 수 있다.
4. Value Object
    * 고유 식별자가 없고, 값으로 동등성을 비교하는 객체로, Aggregate 내부의 상태를 표현하는 데 사용된다.
5. Repository
    * Aggregate Root를 저장하거나 조회하는 데 사용된다.
    * 외부 시스템(예: 데이터베이스)은 Aggregate Root를 통해서만 접근 가능하다.
<br>

**Aggregate의 설계 원칙**  
1. 일관성 경계
    * Aggregate는 일관성을 유지해야 하는 비즈니스 로직의 경계를 정의한다.
    * Aggregate 내부의 모든 상태 변경은 Root를 통해서만 이루어지며, Aggregate 외부에 영향을 미치지 않는다.
2. 단일 트랜잭션
    * 하나의 Aggregate는 하나의 트랜잭션 단위로 처리된다.
    * 여러 Aggregate를 동시에 변경해야 하는 경우, 도메인 이벤트를 통해 비동기로 처리하는 것이 권장된다.
3. ID 기반 참조
    * Aggregate 간에는 직접 참조 대신 ID(식별자)를 사용하여 간접적으로 참조한다.
    * 이는 Aggregate 간의 강한 결합을 피하고, 독립성을 보장하기 위함이다.
4. 크기와 경계 설정
    * Aggregate는 너무 크거나 작지 않도록 설계해야 한다.
        * 너무 크면 성능 문제가 발생할 수 있다.
        * 너무 작으면 경계 간의 상호작용이 복잡해진다.
<br>

### 구성요소
## Value Object
<img width="1245" alt="스크린샷 2024-11-25 오후 8 04 30" src="https://github.com/user-attachments/assets/9da2fa6a-ecb4-40b7-b918-a814fe776414">  
Value Object는 도메인 주도 설계(DDD)에서 사용하는 개념으로, 식별자 없이 값 그 자체로 의미를 가지는 객체를 말한다.  
즉, 특정 엔티티(Entity)에 속하며, 데이터를 표현하고 비즈니스 로직을 수행하는 데 도움을 준다.  
<br>

**Value Object의 역할**  
1. 도메인 표현:
    * 도메인의 특정 속성을 값으로 나타낸다.
    * 예: 주소(Address), 금액(Money), 날짜(Date).
2. 비즈니스 로직 구현:
    * 값과 관련된 비즈니스 로직을 캡슐화하여 엔티티에서 분리.
    * 예: 금액 객체에서 합산, 비교, 곱셈 등의 계산 로직 구현.
3. 재사용 가능성:
    * 여러 엔티티나 애그리거트에서 동일한 Value Object를 재사용할 수 있다.
<br>

**Value Object와 Entity의 차이**  
<img width="554" alt="스크린샷 2024-11-26 오후 8 45 26" src="https://github.com/user-attachments/assets/8244ffd0-f618-44d2-b303-997f8c110d76">  
<br>

**Value Object 설계 시 고려 사항**  
1. 불변성을 유지:
    * 생성 시 값을 설정한 후 변경할 수 없도록 설계.
    * 변경이 필요하면 새로운 Value Object를 생성.
2. 값으로 동일성 판단:
    * 객체의 동일성 비교는 값(내용)으로 판단하며, 객체의 레퍼런스(주소)는 무시.
3. 도메인 로직 포함:
    * 단순히 데이터를 보관하지 말고, 관련 비즈니스 로직을 캡슐화하여 엔티티의 책임을 줄인다.
4. 작고 응집성 있게 설계:
    * 한 가지 역할에 집중하도록 설계.
    * 너무 많은 속성이나 로직을 포함하면 불필요하게 복잡해질 수 있다.
<br>
<br>

## 애그리거트(Aggregate)
<img width="1001" alt="스크린샷 2024-11-26 오후 8 49 06" src="https://github.com/user-attachments/assets/215a7335-cc02-49c2-8b29-5e1f672b2cdb">

애그리거트는 도메인 주도 설계(DDD)에서 도메인 객체(Entity, Value Object)를 묶어서 하나의 일관성 있는 작업 단위로 관리하기 위한 설계 패턴이다. 
비즈니스 로직과 데이터의 경계를 명확히 정의하고, 상태 변경과 트랜잭션을 관리하는 단위로 사용된다.  
<br>

**애그리거트의 구성 요소**
1. 엔티티(Entity) 고유 식별자를 가진 객체로, 애그리거트의 주요 구성 요소다.
2. 밸류 오브젝트(Value Object) 식별자가 없고, 값 자체로 동등성을 판단하는 객체다. 주로 상태를 표현하는 데 사용한다.
3. 애그리거트 루트(Aggregate Root) 애그리거트의 중심이 되는 엔티티다. 외부에서 접근할 때 반드시 루트를 통해야 한다.
4. 리포지토리(Repository) 애그리거트를 저장하거나 조회하는 저장소다.
<br>

**애그리거트의 주요 특징**
1. 일관성 경계 애그리거트는 상태 변경의 경계를 정의한다.  
   모든 상태 변경은 애그리거트 내부에서만 발생하며, 외부에서는 애그리거트의 내부 상태를 직접 변경하지 못한다.
2. 애그리거트 루트 애그리거트 내부의 중심 객체로, 외부에서 애그리거트에 접근할 때 반드시 루트를 통해야 한다.  
   루트는 내부 상태를 관리하고, 외부와의 상호작용을 책임진다.
3. 트랜잭션 단위 애그리거트는 트랜잭션의 단위다.  
   하나의 트랜잭션은 하나의 애그리거트 내에서만 완료되며, 여러 애그리거트를 동시에 수정하지 않는다.
4. ID 기반 참조 애그리거트 간에는 ID 기반으로 간접 참조를 사용한다.  
   이렇게 하면 결합도를 낮출 수 있다.
<br>
<br>

**설계 고려사항 #1**  
<img width="933" alt="스크린샷 2024-11-25 오후 8 15 39" src="https://github.com/user-attachments/assets/4ea8891a-1b11-4d19-93cf-cbf87a5cb4d9">  
* 하나의 Transaction에서는 하나의 Aggregate만 수정함 
* Transaction 일관성과 성공을 보장하도록 Aggregate 구성요소들을 설계해야 함

**특징**  
* 각 Aggregate 은 일관성 있는 Transaction 경계를 형성함 
* 즉, Transaction 제어가 DB에 Commit 될 때, 한 Aggregate 내의 모든 구성요소들은 비즈니스 규칙을 따르면서 일관성 있게 처리되어야 함 
<br>
<br>

**설계 고려사항 #2**  
<img width="1031" alt="스크린샷 2024-11-25 오후 8 15. 05" src="https://github.com/user-attachments/assets/6aba5789-ec18-4586-8840-306023b64dc7"> 
* 하나의일을잘수행할수있도록작게설계해야함
* 작게 설계할 수록 성능이 좋고 확장에 용이함, 변경사항 Commit할 때 문제도 거의 발생되지 않음

**Aggregate의 문제점**  
* 시간이지날수록하위의객체의인스턴스의증가가결국엄청난크기로불어날수있음
* 따라서 하나의 일을 잘 수행할 수 있는 작은 Aggregate로 분리해야 함 
<br>
<br>

**설계 고려사항 #3**  
<img width="1248" alt="스크린샷 2024-11-25 오후 8 20 37" src="https://github.com/user-attachments/assets/731d8533-370b-4702-a830-68ea5de071e2">  
* 한 Aggregate 에서 다른 Aggregate 의 참조는 식별자를 통해서만 참조해야 함 
* 하나의 Transaction 내에서 여러 개의 Aggregate 이 수정되는 것을 방지할 수 있음

**예시**  
<img width="1225" alt="스크린샷 2024-11-25 오후 8 21 34" src="https://github.com/user-attachments/assets/b2c13045-49a0-4177-b4c4-1d2eb6ad3dda">  
* 타겟 , 메시지, 첨부 가 아래와 같이 같은 Aggregate로 묶여 있음.
* 타겟이고객,제품,에이전트를모두직접참조하지않고식별자를통해서참조,식별자는VO로작성됨
* 같은 Aggregate내에 있는 메시지만 직접 참조하고 있음. 
<br>
<br>

**설계 고려사항 #4**  
<img width="1208" alt="스크린샷 2024-11-25 오후 8 22 34" src="https://github.com/user-attachments/assets/3aa45560-ab91-4226-bb1b-83839574629e">
* 하나의 Transaction에서 여러 개의 Aggregate이 갱신되어야 하는 경우, 다른 Aggregate 의 갱신은 비동기 통신을 활용해서 결과적 일관성을 맞춰야 함  
※ 결과적 일관성이란, ‘ 일관성을 유지시켜야 하는 데이터가 일정시간 다른 데이터와 일치 하지 않을 수도 있지만 어느 시점이 되면 결국 일치하게 된다.’ 
<br>
<br>

## 도메인 이벤트
<img width="707" alt="스크린샷 2024-11-25 오후 8 38 49" src="https://github.com/user-attachments/assets/78084215-b628-49b8-9a1c-be282179b41e">   

도메인 이벤트는 도메인 모델에서 발생한 중요한 사건을 나타내는 객체다.  
이 이벤트는 비즈니스적으로 의미 있는 상태 변경이나 발생한 사실을 표현하며, 주로 시스템 내부 또는 다른 도메인 간의 상호작용을 트리거하기 위해 사용된다.  

**도메인 이벤트 특징**
1. 과거형으로 표현
    * 도메인 이벤트는 이미 발생한 사실을 표현하므로, 이름을 과거형으로 짓는다.
    * 예: OrderPlaced(주문이 생성됨), PaymentCompleted(결제가 완료됨).
2. 비즈니스 의미 강조
    * 도메인 이벤트는 비즈니스적으로 중요한 상태 변화를 표현한다.
    * 기술적 구현보다는 도메인 자체의 맥락에 초점이 맞춰진다.
3. 독립적인 객체
    * 도메인 이벤트는 특정 Aggregate 또는 Bounded Context와 연관되지만, 다른 컨텍스트에서도 독립적으로 사용 가능하다.
4. Immutable(불변성)
    * 도메인 이벤트는 발생 시점의 정보를 기록하며, 생성 이후에는 수정되지 않는다.
5. 외부 및 내부 시스템 통합에 사용
    * 같은 시스템 내의 Aggregate 간 또는 다른 시스템 간의 상호작용을 트리거한다.
6. 타임스탬프
    * 이벤트가 발생한 시점을 기록한다.
7.  비동기 작업 처리
    * 도메인 이벤트를 통해 비동기로 작업을 처리하여 시스템의 성능과 확장성을 높인다.
<br>
<br>

## 도메인 서비스
<img width="823" alt="스크린샷 2024-11-25 오후 9 16 19" src="https://github.com/user-attachments/assets/bc30b577-8047-40b7-8cd5-4eab5210b318">   

도메인 서비스는 도메인 주도 설계(DDD)에서 특정 애그리거트나 엔티티에 속하지 않는 도메인 로직을 캡슐화하는 역할을 한다.   
주로 여러 애그리거트나 엔티티가 협력해야 하는 비즈니스 로직을 처리하거나, 개별 객체에 포함시키기 애매한 복잡한 비즈니스 로직을 구현한다.  
하지만, 도메인 서비스는 특정 로직이 엔티티나 애그리거트에 속하지 않을 때만 사용해야 하며, 비즈니스 로직을 중심으로 설계해야 한다.  

**도메인 서비스 특징**  
1. 비즈니스 로직 중심
    * 도메인 서비스는 특정 도메인 문제를 해결하는 비즈니스 로직을 포함하며, 이 로직은 도메인과 밀접하게 연관되어 있다.
2. 상태가 없음 (Stateless)
    * 도메인 서비스는 일반적으로 상태를 가지지 않으며, 순수한 비즈니스 연산만을 수행한다.
3. 애그리거트와 협력
    * 도메인 서비스는 여러 애그리거트 또는 엔티티 간의 협력을 조정하며, 이 과정에서 로직을 캡슐화한다.
4. 도메인 언어와 일치
    * 도메인 서비스의 이름과 메서드는 도메인 언어(Ubiquitous Language)에 부합하도록 명확하게 표현되어야 한다.

**도메인 서비스가 필요한 상황**  
1. 엔티티나 애그리거트에 포함하기 어려운 로직
    * 로직이 특정 애그리거트나 엔티티에 강하게 속하지 않을 때, 도메인 서비스에 위치시킨다.
    * 예: 세금 계산, 배송비 계산.
2. 여러 애그리거트 간의 협력 필요
    * 하나의 트랜잭션에서 여러 애그리거트를 조율하거나, 상태를 변경하는 로직이 필요할 때 사용.
    * 예: 주문 애그리거트와 재고 애그리거트를 동시에 확인하여 주문 가능 여부를 판단.
3. 외부 시스템과의 연계
    * 외부 API 호출이나 데이터베이스 조회와 같이 비즈니스 로직을 처리하는 데 필요한 작업을 캡슐화.

**도메인 서비스의 역할**  
1. 비즈니스 로직 캡슐화
    * 엔티티와 애그리거트가 단순해지고, 비즈니스 로직이 재사용 가능해진다.
2. 도메인 모델의 응집성 유지
    * 도메인 로직을 분리하여 엔티티와 애그리거트가 과도한 책임을 가지는 것을 방지한다.
3. 도메인 간 협력 조정
    * 도메인 서비스는 여러 애그리거트 간의 협력을 조율하여 비즈니스 프로세스를 처리한다.
<br>
<br>

**응용 서비스와의 차이**  
**도메인 서비스**  
1. 도메인 관련 논리 : 도메인 서비스에는 본질적으로 도메인 모델과 관련된 논리를 포함하고, 도메인 내의 특정 엔터티나 값 개체에 자연스럽게 속하지 않는 동작이나 작업을 캡슐화 한다.
2. 복잡한 비즈니스 논리 : 또한 여러 엔티티 또는 값 개체와 관련된 복잡한 비즈니스 규칙이나 작업 구현를 위해 사용된다.
3. 상태 비저장 : 일반적으로 상태 비저장이다. 입력을 받고, 작업을 수행하고, 해당 입력을 기반으로 결과를 반환하지만 장기적인 상태를 유지하지는 않는다.
4. 이름 지정 : 도메인 서비스의 이름은 일반적으로 도메인 개념, 작업 또는 캡슐화하는 특정 동작을 설명하는 동사를 기반으로 지정된다. (예시 : 'PaymentService' 또는 'ReservationService')  
<br>

**응용 프로그램 서비스**  
1. 애플리케이션 흐름 :  애플리케이션의 흐름을 조정하고 도메인 계층(엔티티, 값 개체 및 도메인 서비스)과 외부 영역(예: UI, 저장소, 및 외부 시스템)과의 관계를 상호작용 한다.
2. 트랜잭션 관리 : 특히 데이터베이스와 상호 작용하는 맥락에서 트랜잭션 시작, 커밋 또는 롤백을 포함한 트랜잭션 관리를 처리하는 경우가 많다.
3. 특정 사용 사례(usecase) : 애플리케이션 서비스는 특정 사용 사례 또는 애플리케이션 작업과 밀접하게 연결되어 있다. 이는 사용자나 외부 시스템이 애플리케이션 내에서 수행할 수 있는 usecase나 작업에 매핑되는 경우가 많다.
4. 이름 지정 : 애플리케이션 서비스의 이름은 일반적으로 특정 도메인 개념보다는 지원하는 usecase나 작업의 이름을 따서 지정된다. (예시 : "UserService" 또는 "OrderProcessingService")

도메인 서비스는 복잡한 도메인 논리를 캡슐화하는 데 중점을 두고 도메인 지식을 기반으로 설계된다.  
애플리케이션 서비스는 애플리케이션 수준 문제를 처리하고 상호 작용을 조정하며 트랜잭션을 관리한다. 
<br>
<br>

## 그외
**레파지토리**  
<img width="1021" alt="스크린샷 2024-11-25 오후 9 30 42" src="https://github.com/user-attachments/assets/62023e68-f665-4273-ba02-fa4e07523b6d">  
* 정의:도메인모델의영속성를처리 
* 도메인 모델을 사용하기 위해서 Repository를 통해 도메인 객체를 조회 한 후 도메인 객체의 기능을 실행 
* 도메인 객체(Aggregate)에 대한 생명주기, 즉 영속성 관리 (등록, 조회, 수정, 삭제 시 Aggregate의 일관성 유지) 
* Spring Data JPA의 Repository인터페이스  

**팩토리**  
* 정의 : 복잡한 Entity 또는 Aggregate 생성을 전담하는 객체 
* 특징
    * 객체의 생성 과정과 관련된 지식이 정리된 객체로, 특정 정보를 Factory에 보내면 결과로 Entity 또는 Aggregate 을 생성함 
    * 복잡한생성로직을숨겨,개발자들이내부의복잡함에신경쓰지않아도됨 




























