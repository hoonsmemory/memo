## 질문 리스트

**질문 : 양방향 매핑 언제 사용하나요?**  
그런데 실제 개발을 해보면 복잡한 조회 쿼리에서 양방향 매핑을 하고 싶은 경우가 발생합니다.  
예를 들어서 team 1:N member 이런 관계가 있을 때 team과 member를 fetch join으로 한번에 조회하고 싶은 경우가 있습니다.  

<br>

**질문 : JPQL 조회와 1차 캐시**
JPQL을 실행하면 항상 1차 캐시를 무시하고, 데이터베이스에 직접 SQL을 실행합니다.  
그리고 실행 결과를 1차 캐시에 보관하고, 최종적으로 1차 캐시에 보관된 결과를 반환합니다.  

이런 방식으로 동작하는 이유는 em.find(식별자) 처럼 단순하게 식별자를 조회하는 경우는 1차 캐시에 있는지 없는지 판별하기가 쉬운데,  
JPQL은 광범위하게 데이터를 찾기 때문에 이런 방식의 구현이 어렵습니다.  
그래서 우선 데이터베이스에서 조회부터 하는 것이지요.  
추가로 JPQL을 실행해서, 데이터베이스에서 결과를 가져 왔는데 이미 1차 캐시에 동일한 식별자를 가진 엔티티가 있으면,   
데이터베이스에서 가져온 엔티티를 버리고 1차 캐시에 있는 엔티티를 유지합니다.  
이런방식 덕분에 JPQL을 사용해도 엔티티 동일성을 유지합니다.  

<br>

**질문 : Group By가 필요할 때 JPA에서는 새로운 DTO 클래스를 만들어서 결과를 담으시나요?**  
여러 테이블을 조인하고, group by 까지 하는 경우 이미 엔티티의 범위를 벗어납니다.  
따라서 새로운 DTO 같은 클래스를 만들어서 결과를 받으시는게 맞습니다.  
일반적으로 복잡한 통계 같은 경우 엔티티만으로는 해결하기 어렵기 때문에 DTO로 바로 결과를 받아서 처리하는 방법을 많이 사용합니다.  

참고: 주문 서비스의 주문과 주문 취소 메서드를 보면 비즈니스 로직 대부분이 엔티티에 있다.   
서비스 계층 은 단순히 엔티티에 필요한 요청을 위임하는 역할을 한다.   
이처럼 엔티티가 비즈니스 로직을 가지고 객체 지 향의 특성을 적극 활용하는 것을 [도메인 모델 패턴](http://martinfowler.com/eaaCatalog/domainModel.html)이라 한다.  
반대로 엔티티에는 비즈니스 로직이 거의 없고 서비스 계층에서 대부분 의 비즈니스 로직을 처리하는 것을 트랜잭션 [스크립트 패턴](http://martinfowler.com/eaaCatalog/transactionScript.html)이라 한다.  

<br>

**질문 : @Transactional이 없어도 정상적으로 조회가 가능하네요.**
JPA는 트랜잭션 없이 읽기라는 기능을 지원합니다. 쉽게 이야기해서 트랜잭션이 없어도 데이터를 읽을 수는 있습니다. 그리고 데이터를 읽는 시점에 데이터베이스 커넥션을 사용해서 데이터를 조회합니다.  

참고1 : 엔티티 조회 방식은 페치 조인이나, hibernate.default_batch_fetch_size , @BatchSize 같이 코드를 거의 수정하지 않고, 옵션만 약간 변경해서, 다양한 성능 최적화를 시도할 수 있다.  
반면에 DTO를 직접 조회하는 방식은 성능을 최적화 하거나 성능 최적화 방식을 변경할 때 많은 코드를 변경해야 한다.  
  
참고2 : 개발자는 성능 최적화와 코드 복잡도 사이에서 줄타기를 해야 한다. 항상 그런 것은 아니지만, 보통 성능 최적화는 단순한 코드를 복잡한 코드로 몰고간다.  
엔티티 조회 방식은 JPA가 많은 부분을 최적화 해주기 때문에, 단순한 코드를 유지하면서, 성능을 최적화 할 수 있다.  반면에 DTO 조회 방식은 SQL을 직접 다루는 것과 유사하기 때문에, 둘 사이에 줄타기를 해야 한다.  

<br>

**질문 : Propagation.REQUIRES_NEW로 새로운 트랜잭션을 생성할 경우 엔티티 매니저도 새롭게 생성되는지?**  
[질문 출처](https://chatgpt.com/share/67173905-226c-800e-8ac7-7d0c620128da)  
**OSIV를 사용하지 않는 경우**  
* 트랜잭션 A에서 영속성 컨텍스트 PC1이 생성됩니다.
* Propagation.REQUIRES_NEW를 사용하여 메서드 Y를 호출하면, 트랜잭션 B가 시작되고, 새로운 영속성 컨텍스트 PC2가 생성됩니다.
* 따라서, **새로운 엔티티 매니저(PC2)**가 생성됩니다.
* 이유는 트랜잭션-스코프 영속성 컨텍스트는 트랜잭션당 하나씩 생성되기 때문입니다.
  
**OSIV를 사용하는 경우**  
* OSIV 패턴은 영속성 컨텍스트를 트랜잭션 경계를 넘어 유지합니다.
* HTTP 요청 스레드에 바인딩된 영속성 컨텍스트가 있으므로, 트랜잭션 A와 트랜잭션 B 모두 동일한 영속성 컨텍스트를 공유합니다.
* 이 경우, 새로운 엔티티 매니저가 생성되지 않고, 기존의 엔티티 매니저를 계속 사용합니다.
* 즉, PC1이 트랜잭션 B에서도 사용됩니다.

<br>

**질문 : 엔티티 매니저는 리퀘스트 당 하나만 생성되지 않을 수 있다.**  
[질문 출처](https://perfectacle.github.io/2021/05/24/entity-manager-lifecycle/)  
1. OSIV가 꺼져있으면 트랜잭션이 시작될 때 엔티티 매니저가 생성되고, 트랜잭션이 끝날 때 엔티티 매니저를 종료한다.  
2. OSIV가 꺼져있고, 다른 트랜잭션이라면 엔티티 매니저가 공유되지 않기 때문에 엔티티 매니저의 1차 캐시도 서로 공유되지 않는다.  
3. OSIV가 켜져있으면 요청 당 엔티티 매니저는 한 번 생성되고, 뷰 렌더링이 끝날 때까지 엔티티 매니저는 종료되지 않고 트랜잭션이 다르더라도 1차 캐시가 공유된다.  

<br>

**[페치 조인 관련 좋은 질문]**  
**default_batch_fetch_size 관련질문**  
https://www.inflearn.com/questions/34469  

Fetch Join의 대상은 On절과 Where절을 사용해 필터링해서는 안된다.  
https://www.inflearn.com/questions/15876  
https://www.inflearn.com/questions/59632
