## 상속관계 매핑
<img width="920" alt="스크린샷 2022-09-16 오전 10 02 44" src="https://github.com/user-attachments/assets/59dbbdcd-248a-464e-9775-811d654c2855">
상속관계 매핑: 객체의 상속과 구조와 DB의 슈퍼타입 서브타입 관계를 매핑  
대체적으로 조인 전략을 가져가지만 테이블이 많이 단순하고 변경 가능성이 적을 경우 단일 테이블 전략을 사용하기도 한다.  

**슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법**
* 각각테이블로변환 -> 조인전략 
* 통합 테이블로 변환 -> 단일 테이블 전략
* 서브타입 테이블로 변환 -> 구현 클래스마다 테이블 전략

### 주요 어노테이션 
@Inheritance(strategy=InheritanceType.XXX)  
* JOINED: 조인 전략 
* SINGLE_TABLE: 단일 테이블 전략 
* TABLE_PER_CLASS: 구현 클래스마다 테이블 전략 
@DiscriminatorColumn(name=“DTYPE”) : 부모 클래스에서 사용되는 컬럼명을 변경할 수 있다.  
@DiscriminatorValue(“XXX”) : 자식 클래스에서 사용하고 싶은 별명으로 변경할 수 있다. (단일 테이블 전략일 경우 필수로 생성됨)

### 조인 전략
<img width="1023" alt="스크린샷 2022-09-16 오전 10 06 49" src="https://github.com/user-attachments/assets/7729e49c-d069-4c93-a5a1-ea58be769be6">
ITEM의 ID를 PK, FK로 사용 등록할 때는 둘 다, 조회는 PK로 조인  

**장점** 
* 테이블 정규화 
* 외래 키 참조 무결성 제약조건 활용가능
* 저장공간 효율화

**단점**
* 조회시조인을많이사용,성능저하 
* 조회 쿼리가 복잡함
* 데이터 저장시 INSERT SQL 2번 호출

**상위 타입만 조회 시**  
조인 전략에서 상위 타입을 조회하게 되면 모든 엔티티를 다 조회한다고 인식한다.  
그리고 엔티티를 조회할 때는 모든 데이터가 다 필요하다. 따라서 항상 조인이 발생한다.  

### 단일 테이블 전략
<img width="851" alt="ITEM ID (PK)" src="https://github.com/user-attachments/assets/d092b130-fe83-4f03-9261-8643f4840c0a">

**장점**   
* 조인이 필요 없으므로 일반적으로 조회 성능이 빠름 
* 조회 쿼리가 단순함 
**단점**  
* 자식 엔티티가 매핑한 컬럼은 모두 null 허용 
* 단일테이블에모든것을저장하므로테이블이커질수있다. (상황에 따라서 조회 성능이 오히려 느려질 수 있다.)

### 구현 클래스마다 테이블 전략 
<img width="1020" alt="스크린샷 2022-09-16 오전 10 14 08" src="https://github.com/user-attachments/assets/fda32f41-e20b-4ee2-b4bd-57e0cd5700a9">
부모클래스를 추상 클래스로 만드는 방법. 
부모 테이블 생성이 안된다.
**이 전략은 데이터베이스 설계자와 ORM 전문가 둘 다 추천X**  

**장점**  
* 서브 타입을 명확하게 구분해서 처리할 때 효과적 
* not null 제약조건 사용 가능

**단점**   
* 여러 자식 테이블을 함께 조회할 때 성능이 느림(UNION SQL 필요) 
* 자식 테이블을 통합해서 쿼리하기 어려움 

### @MappedSuperClass
<img width="835" alt="BaseEntity" src="https://github.com/user-attachments/assets/c83e43b0-2fd1-46aa-93a7-30672654181c">
여러 엔티티에 공통되는 필드가 많다면 하나의 클래스로 묶어서 사용할 수 있다.  
테이블과 관계 없고, 단순히 엔티티가 공통으로 사용하는 매핑정보를 모으는 역할(추상 클래스로 구현)  
주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 공통으로 적용하는 정보를 모을 때 사용  
참고: @Entity 클래스는 엔티티나 @MappedSuperclass로 지정한 클래스만 상속 가능  

### 정리
* 상속관계 매핑X
* 엔티티X, 테이블과 매핑X 
* 부모 클래스를 상속 받는 자식 클래스에 매핑 정보만 제공 조회, 검색 불가(em.find(BaseEntity) 불가)
* 직접 생성해서 사용할 일이 없으므로 추상 클래스 권장 













































