## JPA(ORM 프레임워크)
![스크린샷 2022-11-18 오후 1 21 29](https://github.com/user-attachments/assets/fc75389e-5c58-43cf-af05-eedf5e1da5dc)
객체는 객체대로, 관계형 데이터베이스는 관계형 데이터베이스대로 각각의 패러다임에 맞게 설계  
ORM 프레임워크는 중간에서 매핑해주는 역할을 한다.  

## JPA 표준 명세
![스크린샷 2022-11-18 오후 1 30 23](https://github.com/user-attachments/assets/d45152c9-ebf6-4a65-b356-c277faf56be0)
JPA는 표준 인터페이스로 Hibernate, EclipseLink, DataNucleus 등 구현체를 적용할 수 있지만, 80%는 하이버네이트를 사용한다.  
객체지향적인 코드로 데이터베이스 관계형 데이터를 다루기 위해 사용한다.  

## JPA 동작 - 조회
![스크린샷 2022-11-18 오후 1 23 49](https://github.com/user-attachments/assets/f1e1768b-e65f-4888-a21c-c283ba02d529)
find(id)를 통해 조회를 했다면,  
1. JPA는 해당 엔티티를 분석한다.  
2. 엔티티에 기반된 SELECT SQL을 생성한다.  
3. JDBC API를 사용한다.  

### SQL 중심적인 개발의 단점
SQL 중심적인 개발은 SQL에 의존적인 개발을 피하기 어렵다.  
예를 들면 필드값이 변경되면 모든 SQL에서 변경된 필드값을 수정해줘야 한다. (실수로 변경을 안하면 문제가 발생한다.)  
JPA의 목적은 객체를 마치 컬렉션 다루듯이 하는게 목적이다.  

#### 장점
1. 코딩량이 줄어든다.  
2. @Entity를 사용하기 때문에 도메인 클래스를 중요하게 다룬다.  
3. 비지니스 로직을 이해하기 쉽다.(연관관계 매핑된걸 보면 된다.)  
4. 더 많은 테스트 케이스를 작성할 수 있다.  
5. 특정 데이터베이스에 종속되지 않는다.

#### 단점
하이버네이트 이해가 필요하다.( 공부량이 상당히 많다.)

#### 패러다임의 차이
1. 상속
2. 연관관계
3. 데이터 타입
4. 데이터 식별 방법
![스크린샷 2022-11-18 오후 1 38 21](https://github.com/user-attachments/assets/b594e913-1175-45c0-851f-9fcd1e654583)
![개발자가 할일](https://github.com/user-attachments/assets/57dd52f9-1b05-4743-960c-dd1225b6c106)
만약 아이템과 앨범 객체가 있다고 가정한다면,  
두 테이블에 인서트하는 쿼리를 직접 만들어서 실행해야한다.  
하지만 JPA를 쓴다면 persist(앨범)을 해준다면 JPA가 알아서 인서트 쿼리를 만들어 실행한다.

#### 패러다임 불일치
패러다임 불일치를 쉽게 설명하자면, 객체 지향 프로그래밍(OOP)과 관계형 데이터베이스(RDB)가 정보를 표현하고 처리하는 방식이 다르기 때문에 생기는 문제라고 생각하면 된다.  

**객체 지향 프로그래밍과 데이터베이스의 차이**  
객체 지향 프로그래밍 : 데이터를 객체로 표현한다. 객체는 상태(변수)와 행동(메서드)을 포함하고, 상속받거나 구성(Composition)할 수 있다.  
관계형 데이터베이스 : 데이터를 테이블로 표현한다. 테이블은 열(컬럼)과 행(레코드)으로 구성되며, 각각 독립적인 데이터 항목이다. (테이블 간에는 직접적인 참조가 없으며, 외래 키를 통해 간접적으로 참조해야 한다.)
이 둘의 큰 차이점은, **객체는 서로를 직접 참조할 수 있는 반면, 테이블은 데이터를 테이블 간의 관계로 참조한다는 것이다.**  
이런 차이를 해결하기 위해 개발자가 직접 SQL을 작성할 때 복잡한 JOIN 쿼리나 데이터를 변환하는 코드를 작성해야 한다.  
  
**예시: 객체 지향과 관계형 데이터베이스의 차이**
```java
[객체 지향 프로그래밍(OOP)에서의 표현]  
class User {
    String name;
    Address address;  // 컴포지션
}

class Address {
    String city;
    String street;
}
설명 : User 객체는 Address 객체를 직접 참조한다. (사용자는 주소를 하나의 객체로 포함)  

[관계형 데이터베이스에서의 표현]
-- User 테이블
ID   NAME   ADDRESS_ID
1    John   1

-- Address 테이블
ID   CITY   STREET
1    Seoul  Main Street
설명 : 데이터베이스에서는 User 테이블에 ADDRESS_ID라는 외래 키를 사용하여 다른 테이블의 데이터를 참조한다. (Address 테이블과 User 테이블은 분리되어 있으며, 두 테이블 간의 관계를 외래 키로 연결)  
```

**JPA가 해결하는 부분**
JPA는 이런 차이를 자동으로 해결해 준다.  
즉, 객체 간의 참조 관계와 데이터베이스의 관계를 자동으로 매핑해주고, 개발자가 마치 객체만 다루는 것처럼 코드를 작성할 수 있게 도와준다.  
데이터베이스의 복잡한 쿼리를 작성하지 않아도 되므로, 개발자 입장에서는 코드가 더 깔끔하고 유지보수하기 쉬워진다.  
이것이 바로 "패러다임 불일치"를 해결하는 JPA의 중요한 역할이다.  


## 연관관계, 객체 그래프 탐색
![JPA와 연관관계, 객체 그래프 탐색](https://github.com/user-attachments/assets/ce09fe91-80c9-42bc-ad45-d5a86d23ad9d)
위처럼 정말 간단하게 저장이나 조회를 하면 JPA가 알아서 두 테이블에 저장, 조인을 통해 조회해준다.  

**주의사항**
엔티티 매니저 팩토리는 하나만 생성해서 애플리케이션 전체에서 공유 (전체 설정에 대한 정보를 가지고 있다.)  
엔티티 매니저는 요청이 올 때마다 생성되어 사용된다. 쓰레드간에 공유X (사용하고 버려야 한다).  
1. 내부적으로 데이터베이스 커넥션을 사용해서 DB에 CRUD를 한다.  
**JPA의 모든 데이터 변경은 트랜잭션 안에서 실행**  

**Container-Managed EntityManager**  
@PersistenceContext EntityManager em; (기본적으로 트랜잭션-스코프 영속성 컨텍스트를 사용)
**Application-Managed EntityManager**  
EntityManagerFactory emf = Persistence.createEntityManagerFactory("name");

**트랜잭션-스코프 영속성 컨텍스트**  
* 각 트랜잭션마다 새로운 영속성 컨텍스트(즉, 새로운 엔티티 매니저)가 생성  
* 트랜잭션의 생명주기와 영속성 컨텍스트의 생명주기가 동일

## JPA 특징
1. 1차 캐시 : 트랜잭션이 종료되기 전의 영속 상태의 데이터는 영속성 컨텍스트에서 보관한다.  
    1. 동일한 키값으로 다시 조회했을 땐 캐시에 있는 데이터를 가져온다. (1차 캐시에서 조회 시 식별자가 같을 경우 동일한 객체로 갖게 된다.)  
2. 지연 로딩 : 엔티티의 데이터를 사용하는 시점에 로딩  
3. 변경 감지 : set으로 변경이 일어날 경우, 1차 캐시의 스냅샷과 엔티티의 데이터가 다를 경우 변경을 감지하고 업데이트를 한다.(실제로는 commit 되었을 때 업데이트 완료, 주로 update할 때 사용하면 좋다.)  
4. 객체 그래프 탐색 : JPA의 경우 지연 로딩으로 엔티티안에 연관관계 로 매핑된 데이터를 늦게 가져올 수 있다.(프록시)  
5. 트랜잭션을 지원하는 쓰기 지연 : JDBC BATCH SQL 기능을 사용해서 커밋 전까지 인서트한 데이터를 한번에 수행한다. (벌크 연산)  
6. 방언 : 한 DB에 종속되지 않고 방언을 제공

## JPA의 데이터 타입 분류
**엔티티 타입**  
* @Entity로 정의하는 객체 
* 데이터가 변해도 식별자(DB에 저장된 id)로 지속해서 추적 가능 
* 예)회원 엔티티의 키나 나이값을 변경해도 식별자로 인식가능 
**값 타입 **  
* int, Integer, String처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체 
* 식별자가 없고 값만 있으므로 변경시 추적 불가 
* 예) 숫자 100을 200으로 변경하면 완전히 다른 값으로 대체 

## 엔티티의 생명주기
<img width="822" alt="Detached" src="https://github.com/user-attachments/assets/66b6f721-e152-4082-8ee2-cf406376b92d">

### 비영속 (new/transient)
영속성 컨텍스트와 전혀 관계가 없는 새로운 상태  

### 영속 (managed)
영속성 컨텍스트에 관리되는 상태 (1차 캐시에 올라가 있는 상태로 아직 DB에 저장되지 않은 데이터다.)  
식별자(ID)로 구분이 되기 때문에 persist 할 때 엔티티의 ID를 가져온다.(즉 커밋되어 디비에 저장되기 전 이미 ID를 가지고 있다.)  

### 준영속 (detached)
영속성 컨텍스트에 저장되었다가 분리된 상태 (비영속과는 다르게 영속성 컨텍스트에서 관리되었다 제거되는 대상들. 결론은 영속성 컨텍스트에서 관리를 안한다.)  
em.detach(entity) : 특정 엔티티만 준영속 상태로 전환  
em.clear() : 영속성 컨텍스트를 완전히 초기화  
em.close() : 영속성 컨텍스트를 종료  

만약 요청 시 식별자를 가지고 있으면 준영속 엔티티로 변환된다.  
Book book = new Book();  
book.setId(form.getId());  
book.setName(form.getName()); 

**영속성으로 변경하는 방법 2가지**
**1. 변경 감지 기능 사용(식별자를 통해 조회하기)**  
Book item = bookRepository.findOne(form.getId());   
item.setName(name);  
item.setPrice(price);  
item.setStockQuantity(stockQuantity);  

이때 set함수를 쓰게 되면 변경감지가 일어나 변경된 값에 한해서 업데이트가 된다.  

**2. 병합(merge) 사용**  
<img width="897" alt="스크린샷 2022-09-22 오후 4 35 15" src="https://github.com/user-attachments/assets/7dfb5bdd-7a59-4dbb-a8cd-a0e84f1024bd">

준영속 상태에서 영속 상태로 되야할 때 사용.  
  
**병합 동작 방식**  
1. merge()를 실행한다. 
2. 파라미터로 넘어온 준영속 엔티티의 식별자 값(ID)으로 1차 캐시에서 엔티티를 조회한다.  2-1. 만약 1차 캐시에 엔티티가 없으면 데이터베이스에서 엔티티를 조회하고, 1차 캐시에 저장한다. 
3. 조회한 영속 엔티티( mergeMember )에 member 엔티티의 값을 채워 넣는다. (member 엔티티의 모든 값 을 mergeMember에 밀어 넣는다. 이때 mergeMember의 “회원1”이라는 이름이 “회원명변경”으로 바뀐다.) 
4. 영속 상태인 mergeMember를 반환한다.
  
**병합시 동작 방식을 간단히 정리**  
1. 준영속 엔티티의 식별자 값으로 영속 엔티티를 조회한다.
2. 영속 엔티티의 값을 준영속 엔티티의 값으로 모두 교체한다.(병합한다.)
3. 트랜잭션 커밋 시점에 변경 감지 기능이 동작해서 데이터베이스에 UPDATE SQL이 실행
  
**주의사항**
변경 감지 기능을 사용하면 원하는 속성만 선택해서 변경할 수 있지만, 병합을 사용하면 모든 속성이 변경된다.  
병합시 값이 없으면 null 로 업데이트 할 위험도 있다. (병합은 모든 필드를 교체한다.)  
원하는 속성만 변경하고 싶으면 1번으로 해야한다.  
  
### 삭제 (removed)
삭제된 상태 

<img width="996" alt="memberA" src="https://github.com/user-attachments/assets/c09f87c2-9eeb-45ba-8692-57caf2abf2f0">

**커밋을 하는 시점**
1. 내부적으로 flush() 기능을 호출  
2. 엔티티(1차 캐싱된 값)와 스냅샷(해당 값이 최초로 영속 컨텍스트에 들어온 시점)을 비교  
3. 변경된 값에 한해서 UPDATE SQL 생성 후 쓰기 지연 SQL 저장소에 저장  
4. flush (DB에 전송)  
5. commit (DB에 반영)  

**영속성 컨텍스트의 이점**
* 1차 캐시 
* 동일성(identity) 보장 
* 트랜잭션을 지원하는 쓰기 지연 (transactional write-behind) 
* 변경 감지(Dirty Checking) 
* 지연 로딩(Lazy Loading) 
  
영속성 컨텍스트에 데이터가 있는 상태에서 조회를 하게 되면 영속성 컨텍스트에 있던 데이터를 가져온다.  
(영속성 컨텍스트가 관리를 하면  타입을 일치시켜준다. == 비교 시 동일한 값이 된다.)  

**트랜잭션 당 하나의 영속성 컨텍스트가 적용된다. 다르게 말하면 트랜잭션이 달라지면 영속성 컨텍스트도 달라진다.**  

**매우 중요(1차 캐시 동일성 보장)**  
현재 1차 캐시에 다음과 같은 데이터가 있고,  
ID: 1, name: memberA  
  
DB에 다음과 같은 데이터가 있을 때  
ID: 1, name: memberB  

예를 들어서 다음과 같은 JPQL을 실행하면  
select m from member m where m.id = 1  
우선 JPQL이기 때문에 DB에서 쿼리로 id:1, memberB 데이터를 조회한다.  
  
그런데 1차 캐시에 이미 id:1 이라고, 식별자가 충돌난다.  
JPA는 영속성 컨텍스트의 동일성을 보장하기 때문에, DB의 결과 값을 버리고, 1차 캐시에 있는 결과값을 반환합니다.  

## 플러시
영속성 컨텍스트의 변경내용을 데이터베이스에 반영한다. (커밋되는게 아님)  
플러시는 영속성 컨텍스트의 1차 캐시를 비우지 않고, 쓰기 지연 SQL 저장소의 내용을 비운다.  

**플러시 발생 시**
1. 변경 감지(플러시를 통해 변경감지가 진행되면, 이후 Entity값과 스냅샷 같이 같아진다.)  
2. 수정된 엔티티 쓰기 지연 SQL 저장소에 등록  
3. 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송(등록, 수정, 삭제 쿼리)  
플러시 하는 방법 : em. flush(), 트랜잭션 커밋, JPQL 쿼리 실행  
  
**JPQL을 실행할 때 사실 모든 내용을 다 플러시 하는 것이 아니라, 해당 JPQL과 관련 있는 엔티티만 플러시한다.**  































