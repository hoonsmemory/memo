## N+1 문제 해결
JPA의 성능 문제 중 70~80% 가 N+1 문제라고 한다.  
N+1 문제를 해결할 수 있는 방법은 크게 3가지 (Fetch Join, @EntityGraph, @BatchSize) 정도가 있다.  
@EntityGraph, @BatchSize는 JPA 옵션 같은 느낌이고 사실 Fetch Join만 잘 알아도 나머지를 이해하는데 큰 어려움이 없다.  
하지만 Fetch Join을 사용하기 위해서는 여러 주의사항을 알고 있어야 하기 때문에 버전별 예제를 만들어 정리하고자 한다.  

<br>

### N+1 문제
N+1 문제는 연관관계가 매핑된 엔티티를 조회할 때 발생하는 문제로 처음 조회된 쿼리 결과를 바탕으로 N번 이상의 쿼리가 더 실행되는 문제를 말한다.  
결과만 본다면 Fetch Join을 사용한 쿼리와 동일한 데이터를 갖고 있어 정상으로 보일 수 있지만, N번의 쿼리로 인해 성능 문제가 발생될 수 있으므로 반드시 해결해야 한다.  
만약 FetchType.LAZY 옵션을  주더라도 프록시에 의해 뒤늦게 문제가 발생되는 것이지 문제가 해결되는 것이 아니니 방치해두면 안 된다.  

<br>

### 도메인
<img width="837" alt="스크린샷 2024-11-07 오전 11 31 21" src="https://github.com/user-attachments/assets/bec5cb35-409f-4598-ba1e-23e5c36f8c74">

위의 간략히 그린 도메인 모델을 토대로 테스트를 진행해보려고 한다.  
Contest : 대회 엔티티  
Promoter : 주최자 엔티티  
Team : 팀 엔티티  
ContestTeam : 대회의 팀 순위를 관리하는 엔티티 (이하 대회팀 엔티티)  
Participant : 참가자 엔티티  

1. 한 명의 주최자는 하나의 대회를 열 수 있다. (주최자와 대회는 1:1 연관관계를 가진다.)  
2. 대회를 참가하기 위해서는 팀 단위로 참가할 수 있으며 참가 팀의 수를 제한하지 않는다.   
3. 대회가 시작되면 모든 팀의 순위를 매긴다. (대회와 팀 간의 순위를 관리하는 엔티티를 만들고 대회와 1:N, 팀과 1:N 연관관계를 가진다.)  
4. 팀마다 참가할 수 있는 인원은 2명 이상이다. (팀과 참가자는 1:N 연관관계를 가진다.)

<br>

### 엔티티
```java
@Entity
public class Contest {

    @Id @GeneratedValue
    @Column(name = "contest_id")
    private Long id;

    @Column(name = "contest_name")
    private String ContestName;

    @OneToOne(cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    @JoinColumn(name = "promoter_id")
    Promoter promoter;

    @OneToMany(mappedBy = "contest", cascade = CascadeType.ALL)
    List<ContestTeam> contestTeams = new ArrayList<>();
}


@Entity
public class ContestTeam {

    @Id @GeneratedValue
    @Column(name = "Contest_Team_id")
    private Long id;

    private Integer rank;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "contest_id")
    Contest contest;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "team_id")
    Team team;
}


@Entity
public class Participant {
    @Id
    @GeneratedValue
    @Column(name = "member_id")
    private Long id;

    @Column(name = "username")
    private String username;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "team_id")
    private Team team;
}


@Entity
public class Promoter {

    @Id
    @GeneratedValue
    @Column(name = "promoter_id")
    private Long id;

    @Column(name = "promoter_name")
    private String promoterName;

    @OneToOne(mappedBy = "promoter", fetch = FetchType.LAZY)
    private Contest contest;
}


@Entity
public class Team {

    @Id
    @GeneratedValue
    @Column(name = "team_id")
    private Long id;

    @Column(name = "team_name")
    private String teamName;

    @OneToMany(mappedBy = "team")
    private List<Participant> participants = new ArrayList<>();
}
```

도메인 모델을 바탕으로 각 엔티티 간 연관관계를 만들어 주었다.
설명을 조금 덧붙이자면 대회 엔티티와 연관관계를 가진 주최자, 대회팀 엔티티에 영속성 전이를 하였고 @XtoOne으로 연관관계가 매핑된 엔티티에 대해 모두 지연 로딩을 적용시켰다.

<br>

### 테스트 데이터
<img width="846" alt="스크린샷 2024-11-07 오전 11 34 51" src="https://github.com/user-attachments/assets/20ff3cfa-3fc8-4d08-8fe5-e24baf199a88">

총데이터는 이러하다.  
2개의 대회와 2명의 주최자가 존재한다.  
contestA라는 대회에 teamA, teamB가 참여했고, contestB라는 대회에 teamB와 TeamC가 참여했다.  
저장된 총팀은 3팀이며, 총참가자는 6명으로 각 팀당 2명씩 존재한다.  

<br>

### 조회 테스트
조회 테스트를 하기 위해서 여러 버전으로 나누고 대회 엔티티를 기준으로 @XToMany로 연관관계가 매핑된 엔티티부터 조회할 예정이다.  
처음 버전에서 N+1 문제 발생시켜 이를 해결하고, 최종적으로 대회 엔티티를 기준으로 대회 주최자, 대회 순위, 대회 참가팀, 참가팀 멤버를 전부 조회하며 Fetch Join을 사용함에 있어 주의할 점을 기록해보려고 한다.  

<br>

### 버전1
첫 번째 버전은 대회 엔티티 기준으로 @XToOne 연관관계가 매핑된 엔티티만 조회 후 조회된 엔티티를 DTO로 변환한다.  
도메인 모델을 보게 되면 대회와 @XToOne 연관관계가 매핑된 엔티티는 주최자만 되어있는 것을 알 수 있다.  
따라서 버전 1 은 대회 엔티티와 주최자 엔티티만 조회한다.  

**버전 1 테스트 코드**  
```java
//엔티티의 조회한 결과를 담는 DTO
//대회 엔티티와 주최자 엔티티의 값만을 담기 위해 만들어졌다.
@Data
public class SimpleContestDto {
    private Long contestId;
    private String contestName;
    private String promoterName;

    public SimpleContestDto(Contest contest) {
        this.contestId = contest.getId();
        this.contestName = contest.getContestName();
        this.promoterName = contest.getPromoter().getPromoterName(); //지연 로딩 발생
    }
}

//대회 엔티티와 @XToOne 으로 연관관계 매핑된 엔티티만 조회
@RequiredArgsConstructor
@Repository
public class ContestRepository {

    private final EntityManager em;


    public List<Contest> findContestV1() {
        List<Contest> result = em.createQuery(
                        "select c " +
                        "from Contest c " +
                        "join c.promoter p", Contest.class
        ).getResultList();

        return result;
    }
}

//버전1 테스트 쿼리
@SpringBootTest
class ContestRepositoryTest {

    @Autowired
    ContestRepository contestRepository;

    @Transactional
    @Test
    public void v1() {
        List<Contest> result = contestRepository.findContestV1();
        List<SimpleContestDto> contestDtos = result.stream()
                .map(c -> new SimpleContestDto(c))
                .collect(Collectors.toList());
    }
}
```
### 결과
```SQL
=======================================================================================
    select
        contest0_.contest_id as contest_1_2_,
        contest0_.contest_name as contest_2_2_,
        contest0_.promoter_id as promoter3_2_ 
    from
        contest contest0_ 
    inner join
        promoter promoter1_ 
            on contest0_.promoter_id=promoter1_.promoter_id
=======================================================================================
    select
        promoter0_.promoter_id as promoter1_10_0_,
        promoter0_.promoter_name as promoter2_10_0_ 
    from
        promoter promoter0_ 
    where
        promoter0_.promoter_id=?
=======================================================================================
    select
        promoter0_.promoter_id as promoter1_10_0_,
        promoter0_.promoter_name as promoter2_10_0_ 
    from
        promoter promoter0_ 
    where
        promoter0_.promoter_id=?
=======================================================================================

결과
SimpleContestDto{contestId=28, contestName='contestA', promoterName='promoterA'}
SimpleContestDto{contestId=31, contestName='contestB', promoterName='promoterB'}
```

결과를 보면 예상과는 달리 총 3번의 쿼리가 실행된 것을 알 수 있다.  
쿼리를 보면 INNER JOIN을 걸었지만 위와 같이 여러 번의 쿼리가 더 실행되는 문제를 N+1 문제라고 한다.  

**N+1 동작 순서**  
1. 첫 번째 쿼리 실행 (SELECT 절을 확인해보니 주최자 엔티티에 대해서는 ID만 조회되었다.)  
2. 쿼리 완료 후 DTO로 변환 (변환하는 과정에서 주최자 엔티티의 NAME을 가져온다.)  
3. for 문 실행 (총 조회 데이터는 2개이므로 2번 loop)  
3. 첫 번째 loop에서 주최자의 NAME 값이 없다는 걸 판단 후 지연 로딩 발생  
4. 두 번째 쿼리가 실행되어 주최자의  NAME을 가져온다.  
5. 두 번째 loop에서 주최자의 NAME 값이 없다는 걸 판단 후 지연 로딩 발생  
6. 세 번째 쿼리가 실행되어 주최자의 NAME을 가져온다.  

만약 처음 조회된 쿼리에서 주최자 엔티티의 ID가 100개가 있었다면 100번의 name을 가져오기 위해 수많은 쿼리가 실행되었을 것이다.  
또한, 결과만 보고 정상으로 판단해서 운영까지 나간다면 성능에 문제가 생길 우려가 있다. 이렇게 N+1 문제는 상당히 위험한 문제다.  

JPA는 N+1 문제를 해결할 수 있도록 Fetch Join이란 기능을 제공한다.  
사실 Fetch Join 대신 Projection을 이용해 주최자 엔티티의 name을 첫 번째 쿼리에서 가져와 해결하는 방법도 있고 정 안되면 Jdbc Template과 네이티브 쿼리를 작성하는 방법도 있다.  
하지만 이번 시간에는 Fetch Join을 중점으로 사용해서 N+1 문제를 해결해보겠다.  

<br>

### 버전2
이번 버전에서는 버전 1에서 사용된 쿼리에 Fetch Join만 적용해보겠다.

**버전 2 테스트 코드**
```java
//Fetch Join을 적용해서 N+1 문제 해결
public List<Contest> findContestV2() {
    List<Contest> result = em.createQuery(
                    "select c " +
                    "from Contest c " +
                    "join FETCH c.promoter p", Contest.class
    ).getResultList();

    return result;
}
```

**결과**
```SQL
=======================================================================================
    select
        contest0_.contest_id as contest_1_2_0_,
        promoter1_.promoter_id as promoter1_10_1_,
        contest0_.contest_name as contest_2_2_0_,
        contest0_.promoter_id as promoter3_2_0_,
        promoter1_.promoter_name as promoter2_10_1_ 
    from
        contest contest0_ 
    inner join
        promoter promoter1_ 
            on contest0_.promoter_id=promoter1_.promoter_id
=======================================================================================

결과
SimpleContestDto{contestId=28, contestName='contestA', promoterName='promoterA'}
SimpleContestDto{contestId=31, contestName='contestB', promoterName='promoterB'}
```

<br>

<br>

<br>

<br>

<br>















