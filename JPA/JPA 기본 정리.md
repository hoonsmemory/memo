## JPA(ORM 프레임워크)
![스크린샷 2022-11-18 오후 1 21 29](https://github.com/user-attachments/assets/fc75389e-5c58-43cf-af05-eedf5e1da5dc)
객체는 객체대로, 관계형 데이터베이스는 관계형 데이터베이스대로 각각의 패러다임에 맞게 설계  
ORM 프레임워크는 중간에서 매핑해주는 역할을 한다.  

## JPA 표준 명세
![스크린샷 2022-11-18 오후 1 30 23](https://github.com/user-attachments/assets/d45152c9-ebf6-4a65-b356-c277faf56be0)
JPA는 표준 인터페이스로 Hibernate, EclipseLink, DataNucleus 등 구현체를 적용할 수 있지만, 80%는 하이버네이트를 사용한다.  
객체지향적인 코드로 데이터베이스 관계형 데이터를 다루기 위해 사용한다.  

## JPA 동작 - 조회
![스크린샷 2022-11-18 오후 1 23 49](https://github.com/user-attachments/assets/f1e1768b-e65f-4888-a21c-c283ba02d529)
find(id)를 통해 조회를 했다면,  
1. JPA는 해당 엔티티를 분석한다.  
2. 엔티티에 기반된 SELECT SQL을 생성한다.  
3. JDBC API를 사용한다.  

### SQL 중심적인 개발의 단점
SQL 중심적인 개발은 SQL에 의존적인 개발을 피하기 어렵다.  
예를 들면 필드값이 변경되면 모든 SQL에서 변경된 필드값을 수정해줘야 한다. (실수로 변경을 안하면 문제가 발생한다.)  
JPA의 목적은 객체를 마치 컬렉션 다루듯이 하는게 목적이다.  

#### 장점
1. 코딩량이 줄어든다.  
2. @Entity를 사용하기 때문에 도메인 클래스를 중요하게 다룬다.  
3. 비지니스 로직을 이해하기 쉽다.(연관관계 매핑된걸 보면 된다.)  
4. 더 많은 테스트 케이스를 작성할 수 있다.  
5. 특정 데이터베이스에 종속되지 않는다.

#### 단점
하이버네이트 이해가 필요하다.( 공부량이 상당히 많다.)

#### 패러다임의 차이
1. 상속
2. 연관관계
3. 데이터 타입
4. 데이터 식별 방법
![스크린샷 2022-11-18 오후 1 38 21](https://github.com/user-attachments/assets/b594e913-1175-45c0-851f-9fcd1e654583)
![개발자가 할일](https://github.com/user-attachments/assets/57dd52f9-1b05-4743-960c-dd1225b6c106)
만약 아이템과 앨범 객체가 있다고 가정한다면,  
두 테이블에 인서트하는 쿼리를 직접 만들어서 실행해야한다.  
하지만 JPA를 쓴다면 persist(앨범)을 해준다면 JPA가 알아서 인서트 쿼리를 만들어 실행한다.

#### 패러다임 불일치
패러다임 불일치를 쉽게 설명하자면, **객체 지향 프로그래밍(OOP)**과 **관계형 데이터베이스(RDB)**가 정보를 표현하고 처리하는 방식이 다르기 때문에 생기는 문제라고 생각하면 된다.  

**객체 지향 프로그래밍과 데이터베이스의 차이**  
객체 지향 프로그래밍 : 데이터를 객체로 표현한다. 객체는 상태(변수)와 행동(메서드)을 포함하고, 상속받거나 구성(Composition)할 수 있다.  
관계형 데이터베이스 : 데이터를 테이블로 표현한다. 테이블은 열(컬럼)과 행(레코드)으로 구성되며, 각각 독립적인 데이터 항목이다. (테이블 간에는 직접적인 참조가 없으며, 외래 키를 통해 간접적으로 참조해야 한다.)
이 둘의 큰 차이점은, **객체는 서로를 직접 참조할 수 있는 반면, 테이블은 데이터를 테이블 간의 관계로 참조한다는 것이다.**  
이런 차이를 해결하기 위해 개발자가 직접 SQL을 작성할 때 복잡한 JOIN 쿼리나 데이터를 변환하는 코드를 작성해야 한다.  
  
**예시: 객체 지향과 관계형 데이터베이스의 차이**
```java
[객체 지향 프로그래밍(OOP)에서의 표현]  
class User {
    String name;
    Address address;  // 컴포지션
}

class Address {
    String city;
    String street;
}
설명 : User 객체는 Address 객체를 직접 참조한다. (사용자는 주소를 하나의 객체로 포함)  

[관계형 데이터베이스에서의 표현]
-- User 테이블
ID   NAME   ADDRESS_ID
1    John   1

-- Address 테이블
ID   CITY   STREET
1    Seoul  Main Street
설명 : 데이터베이스에서는 User 테이블에 ADDRESS_ID라는 외래 키를 사용하여 다른 테이블의 데이터를 참조한다. (Address 테이블과 User 테이블은 분리되어 있으며, 두 테이블 간의 관계를 외래 키로 연결)  
```

**JPA가 해결하는 부분**
JPA는 이런 차이를 자동으로 해결해 준다.  
즉, 객체 간의 참조 관계와 데이터베이스의 관계를 자동으로 매핑해주고, 개발자가 마치 객체만 다루는 것처럼 코드를 작성할 수 있게 도와준다.  
데이터베이스의 복잡한 쿼리를 작성하지 않아도 되므로, 개발자 입장에서는 코드가 더 깔끔하고 유지보수하기 쉬워진다.  
이것이 바로 "패러다임 불일치"를 해결하는 JPA의 중요한 역할이다.  
















