## JPA(ORM 프레임워크)
![스크린샷 2022-11-18 오후 1 21 29](https://github.com/user-attachments/assets/fc75389e-5c58-43cf-af05-eedf5e1da5dc)
객체는 객체대로, 관계형 데이터베이스는 관계형 데이터베이스대로 각각의 패러다임에 맞게 설계  
ORM 프레임워크는 중간에서 매핑해주는 역할을 한다.  

## JPA 표준 명세
![스크린샷 2022-11-18 오후 1 30 23](https://github.com/user-attachments/assets/d45152c9-ebf6-4a65-b356-c277faf56be0)
JPA는 표준 인터페이스로 Hibernate, EclipseLink, DataNucleus 등 구현체를 적용할 수 있지만, 80%는 하이버네이트를 사용한다.  
객체지향적인 코드로 데이터베이스 관계형 데이터를 다루기 위해 사용한다.  

## JPA 동작 - 조회
![스크린샷 2022-11-18 오후 1 23 49](https://github.com/user-attachments/assets/f1e1768b-e65f-4888-a21c-c283ba02d529)
find(id)를 통해 조회를 했다면,  
1. JPA는 해당 엔티티를 분석한다.  
2. 엔티티에 기반된 SELECT SQL을 생성한다.  
3. JDBC API를 사용한다.  

### SQL 중심적인 개발의 단점
SQL 중심적인 개발은 SQL에 의존적인 개발을 피하기 어렵다.  
예를 들면 필드값이 변경되면 모든 SQL에서 변경된 필드값을 수정해줘야 한다. (실수로 변경을 안하면 문제가 발생한다.)  
JPA의 목적은 객체를 마치 컬렉션 다루듯이 하는게 목적이다.  

#### 장점
1. 코딩량이 줄어든다.  
2. @Entity를 사용하기 때문에 도메인 클래스를 중요하게 다룬다.  
3. 비지니스 로직을 이해하기 쉽다.(연관관계 매핑된걸 보면 된다.)  
4. 더 많은 테스트 케이스를 작성할 수 있다.  
5. 특정 데이터베이스에 종속되지 않는다.

#### 단점
하이버네이트 이해가 필요하다.( 공부량이 상당히 많다.)

#### 패러다임의 차이
1. 상속
2. 연관관계
3. 데이터 타입
4. 데이터 식별 방법
![스크린샷 2022-11-18 오후 1 38 21](https://github.com/user-attachments/assets/b594e913-1175-45c0-851f-9fcd1e654583)
![개발자가 할일](https://github.com/user-attachments/assets/57dd52f9-1b05-4743-960c-dd1225b6c106)
만약 아이템과 앨범 객체가 있다고 가정한다면,  
두 테이블에 인서트하는 쿼리를 직접 만들어서 실행해야한다.  
하지만 JPA를 쓴다면 persist(앨범)을 해준다면 JPA가 알아서 인서트 쿼리를 만들어 실행한다.

#### 패러다임 불일치
패러다임 불일치를 쉽게 설명하자면, 객체 지향 프로그래밍(OOP)과 관계형 데이터베이스(RDB)가 정보를 표현하고 처리하는 방식이 다르기 때문에 생기는 문제라고 생각하면 된다.  

**객체 지향 프로그래밍과 데이터베이스의 차이**  
객체 지향 프로그래밍 : 데이터를 객체로 표현한다. 객체는 상태(변수)와 행동(메서드)을 포함하고, 상속받거나 구성(Composition)할 수 있다.  
관계형 데이터베이스 : 데이터를 테이블로 표현한다. 테이블은 열(컬럼)과 행(레코드)으로 구성되며, 각각 독립적인 데이터 항목이다. (테이블 간에는 직접적인 참조가 없으며, 외래 키를 통해 간접적으로 참조해야 한다.)
이 둘의 큰 차이점은, **객체는 서로를 직접 참조할 수 있는 반면, 테이블은 데이터를 테이블 간의 관계로 참조한다는 것이다.**  
이런 차이를 해결하기 위해 개발자가 직접 SQL을 작성할 때 복잡한 JOIN 쿼리나 데이터를 변환하는 코드를 작성해야 한다.  
  
**예시: 객체 지향과 관계형 데이터베이스의 차이**
```java
[객체 지향 프로그래밍(OOP)에서의 표현]  
class User {
    String name;
    Address address;  // 컴포지션
}

class Address {
    String city;
    String street;
}
설명 : User 객체는 Address 객체를 직접 참조한다. (사용자는 주소를 하나의 객체로 포함)  

[관계형 데이터베이스에서의 표현]
-- User 테이블
ID   NAME   ADDRESS_ID
1    John   1

-- Address 테이블
ID   CITY   STREET
1    Seoul  Main Street
설명 : 데이터베이스에서는 User 테이블에 ADDRESS_ID라는 외래 키를 사용하여 다른 테이블의 데이터를 참조한다. (Address 테이블과 User 테이블은 분리되어 있으며, 두 테이블 간의 관계를 외래 키로 연결)  
```

**JPA가 해결하는 부분**
JPA는 이런 차이를 자동으로 해결해 준다.  
즉, 객체 간의 참조 관계와 데이터베이스의 관계를 자동으로 매핑해주고, 개발자가 마치 객체만 다루는 것처럼 코드를 작성할 수 있게 도와준다.  
데이터베이스의 복잡한 쿼리를 작성하지 않아도 되므로, 개발자 입장에서는 코드가 더 깔끔하고 유지보수하기 쉬워진다.  
이것이 바로 "패러다임 불일치"를 해결하는 JPA의 중요한 역할이다.  


## 연관관계, 객체 그래프 탐색
![JPA와 연관관계, 객체 그래프 탐색](https://github.com/user-attachments/assets/ce09fe91-80c9-42bc-ad45-d5a86d23ad9d)
위처럼 정말 간단하게 저장이나 조회를 하면 JPA가 알아서 두 테이블에 저장, 조인을 통해 조회해준다.  

**주의사항**
엔티티 매니저 팩토리는 하나만 생성해서 애플리케이션 전체에서 공유 (전체 설정에 대한 정보를 가지고 있다.)  
엔티티 매니저는 요청이 올 때마다 생성되어 사용된다. 쓰레드간에 공유X (사용하고 버려야 한다).  
1. 내부적으로 데이터베이스 커넥션을 사용해서 DB에 CRUD를 한다.  
**JPA의 모든 데이터 변경은 트랜잭션 안에서 실행**  

**Container-Managed EntityManager**  
@PersistenceContext EntityManager em; (기본적으로 트랜잭션-스코프 영속성 컨텍스트를 사용)
**Application-Managed EntityManager**  
EntityManagerFactory emf = Persistence.createEntityManagerFactory("name");

**트랜잭션-스코프 영속성 컨텍스트**  
* 각 트랜잭션마다 새로운 영속성 컨텍스트(즉, 새로운 엔티티 매니저)가 생성  
* 트랜잭션의 생명주기와 영속성 컨텍스트의 생명주기가 동일

## JPA 특징
1. 1차 캐시 : 트랜잭션이 종료되기 전의 영속 상태의 데이터는 영속성 컨텍스트에서 보관한다.  
    1. 동일한 키값으로 다시 조회했을 땐 캐시에 있는 데이터를 가져온다. (1차 캐시에서 조회 시 식별자가 같을 경우 동일한 객체로 갖게 된다. )  
2. 지연 로딩 : 엔티티의 데이터를 사용하는 시점에 로딩  
3. 변경 감지 : set으로 변경이 일어날 경우, 1차 캐시의 스냅샷과 엔티티의 데이터가 다를 경우 변경을 감지하고 업데이트를 한다.(실제로는 commit 되었을 때 업데이트 완료, 주로 update할 때 사용하면 좋다.)  
4. 객체 그래프 탐색 : JPA의 경우 지연 로딩으로 엔티티안에 연관관계 로 매핑된 데이터를 늦게 가져올 수 있다.(프록시)  
5. 트랜잭션을 지원하는 쓰기 지연 : JDBC BATCH SQL 기능을 사용해서 커밋 전까지 인서트한 데이터를 한번에 수행한다. (벌크 연산)  
6. 방언 : 한 DB에 종속되지 않고 방언을 제공













