## 오라클 튜닝 에센셜 책 정리
[오라클 튜닝 에센셜](https://m.yes24.com/Goods/Detail/85117060)

**28P : DBMS_XPLAN.DISPLAY_CURSOR**
1. 오라클 내부 힌트 제공(OutLine Data) : 오라클과 사용자가 부여한 힌트를 알 수 있다.
2. Predicate Information 제공 : 조인 조건, 액세스 조건, 필터 조건에 대해 구분이 쉽다.
3. 중요하다고 생각하는 정보만 골라서 볼 수 있도록 각자의 출력 포맷을 설정할 수 있다.
4. 필요한 권한 : V$SQL, V$SESSION, V$SQL_PLAN, V$SQL_PLAN_STATISTICS_ALL

**Predicate Information**
1. Access Predicate (액세스 프레디케이트)
* 정의: access는 데이터 액세스를 제한하기 위해 인덱스 스캔이나 테이블 액세스 시 사용되는 조건을 나타냅니다. 이는 보통 인덱스를 통해 데이터베이스의 행을 찾는 데 사용됩니다.
* 설명: 인덱스 범위 스캔이나 인덱스 고유 스캔과 같은 경우에 사용됩니다. 인덱스의 키 값에 따라 접근하는 방식을 결정합니다.
* 예: SELECT * FROM employees WHERE department_id = 10;
* 위 SQL 문장에서 department_id = 10이 인덱스에 있는 경우, 이는 access predicate로 사용됩니다.

2. Filter Predicate (필터 프레디케이트)
* 정의: filter는 데이터가 액세스된 후 행을 필터링하기 위해 적용되는 조건을 나타냅니다. 이는 테이블 액세스 후 추가적인 필터링 작업을 위해 사용됩니다.
* 설명: 액세스된 데이터 중에서 조건에 맞는 데이터를 걸러내는 데 사용됩니다.
* 예: SELECT * FROM employees WHERE salary > 5000;
* 위 SQL 문장에서 salary > 5000은 테이블 전체 스캔 후 필터링 조건으로 사용됩니다.

**53p : 데이터 저장 구조**
1. 논리 구조 : 테이블 스페이스, 세그먼트, 익스텐트, 오라클 블록
2. 물리 구조 : 데이터 파일, OS 블록

**62p**
1.  인덱스는 풀스캔보다 느릴수도 있다.
2. 순차적으로 검색 시 : 1만 번
3. 이진 트리로 한 명씩 맞추는 방식 : 14 * 사람 수
4. 찾고자 하는 데이터가 정렬된 상태로 서로 모여있기에 전체가 아닌 일정 부분만 읽다가 멈출 수 있다. (Index range scan 가능)

**66p : 랜덤 엑세스와 시퀀셜 액세스**
1. 시퀀셜 엑세스를 진행할 때, 최종 결과 집합으로 선정되는 비중을 높인다.
2. 랜덤 액세스 발생량을 최소화한다.

**68p (나중에 중간 부분 다시 읽기)**
1. 2번 구간은 시퀀셜 액세스 방식으로 접근하며, 최종 결과 집합으로 선택되는 비중과 전체 테이블 건수 대비 얼마만큼의 구간을 읽어야 하는지에 대해 비중이 중요하다.
2. 3번 구간은 SQL에 부하가 심하게 발생한다면, 이 구간일 경우가 높다.
3. 인덱스 블록에는 데이터가 정렬되어 있고 인덱스 값과 해당 값의 원본 위치 정보가 있다.
4. 인덱스 값의 물리적 크기와 원본 데이터의 물리적 크기는 테이블 전체 컬럼을 전부 인덱스로 잡지 않는 한 인덱스 값의 크기가 작기 때문에 한 개의 블록에 저장할 수 있는 건수는 인덱스가 훨씬 많다고 볼 수 있다.
5. 시퀀셜 액세스 방식으로 스캔할 때 필요한 구간만큼만 스캔을 하도록 하고, 테이블로 접근한 데이터는 최대한 결과 집합으로 선택될 수 있도록 인덱스를 구성해 주는 것이 가장 좋다.

**70p : 버퍼 피닝**
1. 오라클은 블록 읽기의 비효율을 줄이기 위해 몇 가지 노력을 하게 되는데 버퍼 피닝이 그 중 하나이다.
2. 버퍼 피닝이란 연속하여 같은 블록을 방문할 경우 해당 블록을 얻기까지의 과정을 생략하는 기능이다.
3. 자주 접근하는 데이터 블록을 메모리 버퍼 캐시(Buffer Cache)에 상주하게 함으로써 디스크로부터 데이터를 읽어오는 비용을 줄인다.
4. 블록 방문을 다시하지 않아 블록에 방문한 수치가 증가하지 않는다.
5. 테이블 데이터가 특정 인덱스와 비슷하게 정렬되어 있다면(클러스터링 팩터가 좋다면) 논리적 블록 읽기 횟수가 상상했던 것 보다 매우 적게 나타날 수 있다.
6. 비교적 시간 순으로 데이터가 발생했다면(정렬되어 있다면) 쿼리 속도가 더 빠를 수 있다.
? : 그래서 인덱스는 정렬되어 있기 때문에 속도가 빠른건가??

**71p : 싱글 블록 I/O vs 멀티 블록 I/O**
1. 싱글 블록 I/O : 한 번의 콜을 요청할 때 한 개의 블록만을 읽어 DB 버퍼 캐시에 적재 (인덱스)
2. 멀티 블록 I/O : 한 번의 콜을 요청할 때 여러 블록을 읽어 DB 버퍼 캐시에 적재 (풀스캔 : 테이블 전체를 읽는 경우)
3. 오라클 입장에서는 전체 테이블 데이터에서 필요한 데이터만 골라서 읽는다고 생각하기 때문에 싱글 블록 I/O를 진행한다.
4. 멀티 블록 I/O의 블록 개수를 결정하는 요소는 1) 익스텐트가 가지는 블록 개수, 2)db_file_multiblock_read_count 파라미터
5. 둘 중 작은 작은 값으로 설정된 만큼 읽어올 수 있다.
6. 한 번에 많은 블록을 읽는다고 성능적으로 좋은게 아니다.

**72p : I/O 효율화, 왜 중요한가?**
1. 최대한 노력을 기울여 최소 블록만 읽을 수 있도록 쿼리를 작성한다.
2. 오라클(그 중에서도 옵티마이저)이 최적의 경로를 판단할 수 있도록 통계 정보를 제공한다.
3. 그래도 오라클이 잘못된 판단을 할 경우, 오라클이 제공하는 힌트를 사용해 최적의 경로를 유도할 수 있어야 한다.

**75p (*) : 인덱스의 특징**
1. 인덱스 블록(인덱스를 저장하는 가장 작은 단위)은 인덱스로 지정된 컬럼의 값과 해당 데이터의 원본을 찾아갈 수 있는 주소로 구성되어 있다.
2. 인덱스의 모든 컬럼이 NULL인 경우에는 인덱스를 만들지 않는다.
3. 여러 개의 컬럼으로 구성된 인덱스라면 모든 컬럼이 NULL이 아니면 인덱스는 만들어진다.
4. ROWID 구조 (데이터 오브젝트 번호(6) 테이블 등, 데이터 파일 번호(3), 블록 번호(6), 로우 번호(3)
5. 인덱스는 테이블 컬럼 값과 ROWID를 가지고 있다.
6. 인덱스에서 원하는 값을 찾은 후 테이블의 원본 데이터에 접근할 떄, ROWID를 가지고 테이블에 접근한다.
7. 만약 ROWID를 알고 있다면 인덱스를 통하지 않고 바로 데이터에 접근이 가능하다.
8. ROWID 순으로 정렬하면 같은 블록끼리 모여 있어 버퍼 피닝 효과를 만들 수 있다.
9. 같은 인덱스를 사용하지만, 테이블에 저장된 데이터 배치 상태에 따라 성능이 달라질 수 있다.(94p, 클러스터링 팩트)

**78p (*) : 인덱스 스캔 방식**
1. Index Unique Scan : 루트 블록에서 시작하여 브랜치 블록을 거쳐 리프 블록까지 내려가서 최종 데이터가 지정된 테이블 블록을 읽어 단 한 건을 찾는다.
2. 결합 인덱스의 경우 인덱스 컬럼의 일부 컬럼만으로 검색할 때 Index Range Scan으로 바뀔 수 있다.
3. PK 컬럼 또는 Unique Index 컬럼이 여러 개로 구성되어 있는데 이중 일부만 이용할 때는 Index Range Scan, Index Full Scan 으로 변경되기도 한다.
4. Index Range Scan : 인덱스를 수직 탐색하다가 리프 블록에 도달하여 시작 지점을 찾고, 필요한 만큼의 범위를 순차적으로 탐색한다.(범위를 두어 찾고자 하는 데이터만 찾음)
5. Index Skip Scan : 인덱스가 만약 CD, NM 으로 되어 있는데 where절에 선행 컬럼(CD)이 없다면 동작한다. 선행 컬럼의 가짓수가 성능을 좌우한다.
6. Index Fast Full Scan : 유일하게 멀티블록 I/O 방식으로 스캔, 정렬 순서가 보장되지 않음, SQL문에 포함된 모든 컬럼이 인덱스에 포함되어야 한다.

**86p : 인덱스 스캔 유도 방법**
1. 생성 방법1 : 테이블명 또는 테이블 엘리어스 <공백> 인덱스명 /*+ INDEX(T T_X01) */
2. 생성 방법2 : 테이블명 또는 테이블 엘리어스 <공백> 컬럼..  /*+ INDEX(T (A, B, C)) */
3. INDEX_COMBINE, INDEX_DESC, INDEX_RS, INDEX_SS 등이 있다.

**90p(*): 인덱스 스캔 동작 원리**
1. 인덱스 컬럼 사용법 : where substr(nm, 1, 2,) = '한우' 대신 where nm like '한우%' 로 사용 ==> 컬럼을 가공하면, 해당 인덱스가 사라지므로 사용할 수 없다.
2. 묵시적 형변환 조심.. 예를 들어 varchar2 로 만들어진 date 컬럼에 TO_DATE('20240711') 으로 한다면 쿼리 수행 속도가 상당히 느려질 수 있다. (그외 TO_CHAR)

**93p: 데이터 조회와 DB 버퍼 캐시에 저장되는 과정(꼭 다시 읽어보기)**
1. ROWID의 정보 중에는 해당 데이터가 어느 블록에 있는지 

**97p : 클러스터링 팩터**

**98p : 인덱스 스캔에서 비효율 판단하기 (설명 다시 읽어보기)**
1. 인덱스가 능사는 아니다.
2. 어떤 경우에 인덱스 스캔의 비효율이 발생하는지를 판단할 수 있어야 한다.
3. 실행계획 분석한 내용 확인

**실행 계획 항목 설명**  
1. Id:
    * 정의: 각 실행 계획 단계의 고유 식별자입니다. 이 값은 실행 계획 트리의 각 노드에 해당합니다.
    * 이해 방법: 트리 구조에서 부모와 자식 노드를 나타내기 위해 사용됩니다. 일반적으로 Id가 낮을수록 상위 단계에 위치합니다.
2. Operation:
    * 정의: 각 단계에서 수행되는 작업의 유형을 나타냅니다. 예를 들어, TABLE ACCESS FULL, INDEX RANGE SCAN 등이 있습니다.
    * 이해 방법: 이 항목을 통해 특정 단계에서 데이터베이스가 어떤 작업을 수행하는지 알 수 있습니다.
3. Name:
    * 정의: 각 작업에서 접근하는 객체(테이블, 인덱스 등)의 이름을 나타냅니다.
    * 이해 방법: SQL 문장이 어떤 테이블이나 인덱스를 사용하는지 확인할 수 있습니다.
4. Starts:
    * 정의: 특정 작업이 실행된 횟수를 나타냅니다.
    * 이해 방법: 반복적인 작업이 얼마나 자주 실행되었는지 파악할 수 있습니다. 높은 값은 비효율적인 반복 작업을 나타낼 수 있습니다.
5. A-Rows (Actual Rows):
    * 정의: 각 작업에서 실제로 처리된 행의 수를 나타냅니다.
    * 이해 방법: 예상된 행 수와 실제 처리된 행 수를 비교하여 실행 계획의 효율성을 평가할 수 있습니다.
6. A-Time (Actual Time):
    * 정의: 각 작업이 실제로 소요된 시간을 나타냅니다.
    * 이해 방법: 예상 시간과 실제 시간을 비교하여 특정 작업의 성능을 평가할 수 있습니다. 시간은 주로 HH:MI 형식으로 표시됩니다.
7. Buffers:
    * 정의: 각 작업에서 사용된 버퍼의 수를 나타냅니다.
    * 이해 방법: 메모리 사용량을 평가하는 데 도움이 됩니다. 높은 버퍼 수는 메모리 사용이 많은 작업을 나타낼 수 있습니다.
8. Reads:
    * 정의: 각 작업에서 발생한 블록 읽기(디스크 I/O)의 수를 나타냅니다.
    * 이해 방법: 디스크 I/O 활동을 평가할 수 있습니다. 높은 값은 I/O 집약적인 작업을 나타내며, 성능 병목을 초래할 수 있습니다.


**102p : 기존 인덱스에 컬럼 추가하기**
1. 인덱스를 추가하면 성능적으로 빨라질 순 있어도, 인덱스 테이블 데이터가 증가하는 단점이 있다. (트레이드 오프) (105p 마지막 줄)

**106p : PK 인덱스 확장하기 **
1. 만약 상품 ID(PK)를 통해 상품명을 가져온다면, 상품명도 인덱스에 추가 하는게 좋다.(상품명을 찾기 위해 테이블 방문을 시도하지 않는다.)

**109p : 인덱스에서만 처리하기**
1. 커버링 인덱스는 오라클에서 지원하지 않아, 인덱스에 컬럼으로 추가해야한다.
2. SELECT 절에 나열된 컬럼들도 포함하여 인덱스를 생성하면, 인덱스만으로 쿼리를 해결할 수 있어 성능이 향상될 수 있다.

**111p : 인덱스 스캔 범위 계산**
1. 조건절에 따른 인덱스 스캔 범위 파악 조건절의 모든 조건이 등치(=) 조건이라면 인덱스 컬럼 순서가 중요하지 않지만, 범위 조건과 섞여 있다면 범위 조건 뒤부터는 원하지 않는 구간까지 스캔한다. (실행계획이 동일하게 나오더라도 인덱스 컬럼 순서에 따라 결과가 다르게 나올 수 있다.)

**114p : 인덱스 설계 기준 및 전략**
1. 어떠한 기준과 원칙을 만들고, 빈도수와 데이터 값의 종류 등 여러 요소를 고려해야한다. (하나의 인덱스가 가급적 여러 SQL문에서 사용할 수 있도록 만들어야 한다.)
2. 등치 조건으로 사용되고 자주 사용되는 컬럼을 앞쪽으로 만든다. (범위 조건 이후에 등장하는 컬럼은 인덱스 필터로 동작하기 떄문에 효율이 떨어진다.)
3. 등치 조건으로 사용되고, 값의 수(Distinct Value)가 적은 컬럼을 앞쪽으로 만든다. (인덱스 스킵 스캔이 동작할 수 있도록 유도)
4. 자주 사용되는 컬럼을 선정한다.
5. 테이블 랜덤 액세스를 줄인다.
6. 대용량 테이블에서 정렬하는 경우에는 인덱스를 이용해 정렬하는 것이 가장 효율이 좋다.


**116p : 조인의 종류**
1. 크게 NL(Nested Loop), 소트 머지, 해시, 카다시안(Cartesian), 블룸 필터(Bloom Filter) 조인이 있다.

**116p : NL 조인**
1. 두 테이블 조인을 할 떄, 드라이빙 테이블(Outer 테이블)에서 읽은 결과를 Inner 테이블로 건건이 조인을 시도하는 방식이다.
2. 아우터 테이블 : 조인에서 먼저 처리되는 테이블로, 이 테이블의 각 행마다 이너 테이블을 탐색한다.
3. 이너 테이블 : 아우터 테이블의 각 행에 대해 반복적으로 접근하는 테이블이다.
4. 소량의 데이터를 가진 테이블이 아우터로 되는 것이 유리하다.
5. 힌트 사용법 : /*+ ORDERED USE_NL(E) */  | ORDERED : FROM 절에 나열된 순서대로 테이블을 읽도록 명령, USE_NL(E) : E와 조인할 때 NL 조인 사용
6. NL조인은 랜덤 액세스 방식이라 비효율적으로 보이지만, 한 건씩 처리하기 때문에 처리 중간에 멈추는 경우(대표적으로 페이징 처리)에서 만큼은 적절한 인덱스만 있다면 극적으로 처리속도 개선의 여지가 있다.
