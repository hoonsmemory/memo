## 객체지향 설계 원칙
**결과적으로 객체지향 설계는 요구사항이 변경될 때 코드를 보다 쉽고 안전하게 수정하기 위함이다.**  

#### 1. 다른 객체의 요청을 처리하기 위해 필요한 행동(협력에 필요한 행동)을 먼저 결정하고, 행동에 적합한 객체를 나중에 선택하라
![스크린샷 2024-10-11 오후 2 51 54](https://github.com/user-attachments/assets/5abd7b24-28c8-4e27-a2ee-91521899da4d)
![행동을 구현하는데 적합한 데이터를 결정](https://github.com/user-attachments/assets/48c1de7b-cad4-454c-9313-5cf3ae080170)
![스크린샷 2024-10-11 오후 2 52 09](https://github.com/user-attachments/assets/9d990609-cf34-4528-a2f2-e55e2dd6d958)


객체의 행동은 고립된 상태가 아닌 다른 객체와의 협력이라는 문맥 안에서 결정해야 한다.  
클라이언트의 요청을 먼저 결정한 후에 이 요청을 처리할 객체를 나중에 선택해야 한다.  

위 그림처럼 "할인 금액을 계산하라" 라는 요청이 먼저 존재하고 이 요청을 처리하기에 적합한 객체(DiscountPolicy)를 나중에 선택해야 한다. **(행동이 객체를 결정)**  
**행동을 먼저 결정하고 객체를 나중에 선택하는 방식으로 설계하면 ,변경에 유연하고 필요한 요소만 포함하는 클래스를 얻을 수 있다.**  
행동이 결정되면 앞에서 살펴본 원칙에 따라 행동을 부연하는데 적합한 데이터를 선택하면 된다. 
이렇게 데이터를 나중에 선택하면, 데이터가 변경되더라도 외부에 영향이 미치지 않는다.  

**협력 : 객체가 다른 객체에게 도움을 얻기 위해 요청하고 응답하는 과정**  

<br>

#### 2. 객체의 행동을 먼저 구현하고, 행동에 필요한 데이터를 나중에 선택하라
![절차적인 설계 다시 살펴보기](https://github.com/user-attachments/assets/c0940bb2-9893-4de6-8dd8-62a0400ea6fb)
![절차적인 설계 다시 살펴보기](https://github.com/user-attachments/assets/37800523-96e1-48bb-8643-16ec1d1abb1b)


절차적인 설계에서는 데이터(DiscountPolicy)와 프로세스(ReservationService)를 독립적인 단위로 나눠서 설계를 한다.  
사용될 목록을 고려하지 않고 데이터를 설계하기 때문에 모든 경우에 사용 가능하도록 Getter, Setter를 추가한다.  
이런 추측에 의한 설계 전략이 나쁜 이유는 겉으로 보기에는 필드를 캡슐화한것처럼 보이지만 실제로는 Getter, Setter를 통해 클래스 내부를 그대로 드러내고 있기 때문이다.  
데이터의 구조가 프로세스에 그대로 노출되기 때문에 데이터의 내부 구조가 수정되면 데이터를 사용하는 프로세스도 함께 수정될 수밖에 없다.  
**따라서, 변경으로 인한 문제를 해결하기 위해서는 데이터와 프로세스를 하나의 모듈 안에 함께 작성해야한다. (책임의 이동)**  

![스크린샷 2024-10-11 오후 2 37 38](https://github.com/user-attachments/assets/068e38cf-d784-4a32-b0b1-2dd94d9617be)
설계를 개선하기 전에는 내부의 데이터 구조에 의존했지만, 설계를 개선한 후에는 외부에 공개하는 메서드에 의존한다.  
**데이터를 자유롭게 수정하기 위해서는 외부 객체가 행동에 의존하도록 만들어야 한다.**  
외부 객체가 데이터에 의존하지 않도록 만드는 가장 좋은 방법은 데이터를 결정하기 전에 먼저 행동부터 결정하는 것이다.  
데이터가 없는 상태에서 행동을 먼저 결정하면 외부에서는 데이터에 대해서는 알 수 없기 때문에 행동에 의존할 수 밖에 없다.  


![스크린샷 2024-10-11 오후 2 41 49](https://github.com/user-attachments/assets/e3334651-1484-47d7-b606-995b65e535cb)
![외부 객체의 요청에 용답하기 위해 필요](https://github.com/user-attachments/assets/cf7ee698-c059-44a7-86c5-65d56953acd7)
![데이터가 아닌 행동에 초점](https://github.com/user-attachments/assets/beb51a15-812b-47cd-890e-e8812568a8c2)

외부 객체의 요청에 응답하기 위한 메서드(행동)를 먼저 구현 후 메서드에 필요한 데이터를 추가한다.  

<br>

## 객체지향 설계 순서
![협력에 필요한 행동을 먼저 결정하고](https://github.com/user-attachments/assets/064e5aff-5de3-4782-a176-9bfb532bc98e)
![스크린샷 2024-10-11 오후 3 04 54](https://github.com/user-attachments/assets/8bfd490e-ce92-48f7-86b1-dafb2f3b7642)
![스크린샷 2024-10-11 오후 3 05 12](https://github.com/user-attachments/assets/d233cc22-634c-4a3c-9111-6ee752ccef9c)
**객체지향 설계는 객체 사이의 협력을 설계하고 그 후에 클래스의 내부 구조를 구현하는 순서로 진행한다.**  
협력에 필요한 행동을 먼저 결정하고, 행동에 적합한 객체를 나중에 선택하면 객체 사이의 협력이 설계된다.  
이렇게 선택된 행동을 구현하면서 필요한 데이터를 나중에 결정하면 클래스의 내부 구현이 완성된다.  
**책임 주도 설계(Responsibility-Driven Design) : 객체들의 협력 관계를 기반으로 애플리케이션을 설계하는 방법(객체가 수행할 책임을 기반으로 객체와 객체 사이의 협력을 설계하는 방식)**  

객체지향에서 런타임 구성 요소는 객체이고(클래스 기반의 객체지향 언어의 경우), 컴파일타임 구성 요소(코드의 단위)는 클래스이기 때문에 객체의 구조와 객체 사이의 협력 관계를 먼저 결정한 후에 클래스 내부와 클래스 사이의 관계를 설계해야 한다.  

오브젝트(257 페이지)  
의존성과 관련해서 다루어야 하는 또 다른 주제는 **런타임 의존성(run-time dependency)**과 **컴파일타임 의존성(compile-time dependency)**의 차이다. 먼저 여기에서 사용하는 런타임과 컴파일타임의 의미를 이해할 필요가 있다.  
런타임은 간단하다. 말 그대로 애플리케이션이 실행되는 시점을 가리킨다. 컴파일타임은 약간 미묘하다. 일반적으로 컴파일타임이란 작성된 코드를 컴파일하는 시점을 가리키지만 문맥에 따라서는 **코드 그 자체를 가리키기도 한다.** 컴파일 타임 의존성이 바로 이런 경우에 해당한다. 컴파일타임 의존성이라는 용어가 중요하게 생각하는 것은 시간이 아니라 우리가 작성한 코드의 구조이기 때문이다. 또한 동적 타입 언어의 경우에는 컴파일 타임이 존재하지 않기 때문에 컴파일 타임 의존성이라는 용어를 실제로 컴파일이 수행되는 시점으로 이해하면 의미가 모호해질 수 있다. **따라서 어딘가에서 컴파일타임이라는 용어를 보게된다면 그것이 정말 컴파일이 진행되는 시점을 가리키는 것인지 아니면 코드를 작성하는 시점을 가리키는 것인지를 파악하는 것이 중요하다.**  
객체지향 애플리케이션에서 **런타임**의 주인공은 **객체**다. 따라서 런타임 의존성이 다루는 주제는 객체 사이의 의존성이다. 반면에 **코드** 관점에서 주인공은 **클래스**다. 따라서 컴파일타임 의존성이 다루는 주제는 클래스 사이의 의존성이다.  

<br>

## 객체지향 설계 흐름
![스크린샷 2024-10-11 오후 3 14 41](https://github.com/user-attachments/assets/9dcddf3e-e70d-48f2-b299-1963f2bfbe76)
1. 하나의 객체를 설계하기 위해서는 먼저 설계를 위한 문맥이 필요하다. (객체가 다른 객체와 협력하기 위해 보내는 요청을 객체를 설계하기 위한 문맥으로 활용한다.)  
2. 요청을 처리하는데 필요한 행동(책임)을 결정한다.  
3. 책임을 결정 후 책임을 수행하는데 적합한 객체를 선택한다.  
4. 책임 구현(클래스와 메서드를 이용해서 구현)  
5. 책임을 구현하는데 필요한 데이터를 결정하고 클래스의 필드로 정의한다.  
