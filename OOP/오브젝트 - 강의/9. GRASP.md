## GRASP(General Responsibility Assignment Software Pattern) 일반적인 책임 할당을 위한 소프트웨어 패턴
![9가지 GRASP 패턴](https://github.com/user-attachments/assets/c20b07ad-8490-4748-9375-7b5ca5bcca42)
![책임과 협력을 표현하기 위한 객체지향 설계 도구](https://github.com/user-attachments/assets/80f50d65-2f90-42f6-a4f2-3052b4048bf9)
![CRC는 객체 협력을 위한 설계 도구](https://github.com/user-attachments/assets/34304370-74b7-4d2e-9eba-654a27575170)
CRC(Candidate, Responsibility, Collaborate)는 켄트백과 워드 커닝엄이 객체지향 설계를 가르치기 위한 도구로 물리적인 인덱스 카드를 이용해서 책임을 기술할 수 있는 설계 도구이다.  
CRC카드는 클래스와 유사해 보이지만, 정적인 클래스가 아니라 런타임에 실제로 행동을 수행하는 동적인 객체를 나타내야한다.  

Candidate(후보, 역할) : 객체 또는 역할을 기입  
Responsibility(책임) : 객체가 수행할 책임을 기입  
Collaborator(협력자) : 협력할 다른 객체를 기입  

<br>
<br>

### 정보 전문가 패턴
![스크린샷 2024-10-11 오후 6 07 53](https://github.com/user-attachments/assets/593b2eb5-aab3-4b9a-8540-49098e87a6ad)
책임을 할당할 때 제일 먼저 살펴봐야 하는 가장 기본이 되는 패턴이다.  
어떤 책임을 객체에게 할당할 때 적용할 수 있는 가장 일반적인 원칙을 찾는 문제를 해결하기 위해 사용한다.  
책임을 수행하는데 필요한 정보를 가장 많이 알고있는 객체에 할당해야 한다.  

![정보는 데이터가 아니라 행동](https://github.com/user-attachments/assets/64645bc0-c4b5-4a07-b0b7-fcc5cc57807e)
여기에서 말하는 정보란 객체가 내부에 저정하고 있는 데이터를 의미하는 것이 아니라, 외부에 제겅하는 행동이라는 사실을 이해해야 한다.  
객체지향 관점에서는 객체가 내부에 해당 데이터를 저장하고 있지 않더라도 정보에 대한 질문에 답할 수 있다면, 해당 정보를 책임지고 있는 것으로 간주한다.  

**함께 일하는 사람들 중 대다수가 합리적이라고 동의하면 그게 답이 된다.**  
객체지향 설계의 목표는 완벽한 모델을 구축하는 것이 아니라 여러 사람이 동의할 수 있는 모델을 구축할 수 있다면 목표를 달성했다고 볼 수 있다.  

![스크린샷 2024-10-15 오후 7 52 50](https://github.com/user-attachments/assets/bc558b7c-a7c6-4695-bd67-5163d91516e3)
정보는 행동 관점이기 때문에 내부의 데이터가 다르더라도 외부에서 보이는 행동은 동일한 것이다.  
위 그림과 같이 **객체 내부의 데이터 저장 방식과 메서드의 수행 방식을 구현**이라 부르고, **외부에서 객체가 행동을 수행하도록 요청할 수 있는 메서드의 시그니처를 인터페이스**라고 부른다.  
객체가 수행할 책임만 동일하게 유지한다면 내부의 구현 방식을 바꾸더라도 외부에 영향을 미치지 않는다.  
책임만 잘 정의한다면 객체 내부의 구현은 언제라도 바꿀 수 있다. (객체가 수행할 행동 또는 책임이 내부 구현보다 훨씬 중요하다. = 인터페이스 설계의 중요성?)  
**행동을 먼저 결정한 후에 객체를 선택하고 데이터를 가장 마지막에 결정한 이유가 바로 이것 때문이다. 행동을 먼저 결정해서 외부의 객체가 인터페이스에 의존하도록 만들면 객체 내부의 구현을 변경하더라도 외부에 영향을 미치지 않을 수 있다.**  

![reserve(screening)](https://github.com/user-attachments/assets/db816e78-e0e3-4f20-8220-8c8d512c6d18)
객체는 스스로 책임을 수행하는 자율적인 존재이기 때문에 목적어를 주어로 바꾸면 능동적으로 그 행동을 수행하도록 만들 수 있다.  
책임을 할당한 후보가 혼동된다면, 책임에서 목적어를 찾은 다음 그 목적어에 책임을 할당해 보면 된다.  

<br>
<br>

### 창조자 패턴과 낮은 결합도 패턴  
![스크린샷 2024-10-21 오후 2 40 30](https://github.com/user-attachments/assets/fd708fbc-09d3-49a0-b010-ff8b676dd2d8)
창조자 패턴은 새로운 인스턴스를 생성하는 책임을 어떤 객체에게 할당할 지 결정해야 할 때 적용할 수 있다.  
1. 생성되는 객체를 포함(낮은 결합도).  
2. 참조하는 객체, 생성되는 객체를 기록하는 객체(낮은 결합도).  
3. 생성되는 객체를 긴밀하게 사용하는 객체(낮은 결합도).  
4. 생성되는 객체를 초기화하는데 필요한 정보를 알고 있는 객체(정보 전문가).

생성할 책임을 맡게 될 객체는 생성되는 객체와 밀접한 관계를 맺고 있는 객체라는 사실을 알 수 있다.  
  
  
![스크린샷 2024-10-21 오후 2 34 42](https://github.com/user-attachments/assets/0a2c565c-5b38-457f-aad8-8d5ce6333359)
창조자 패턴의 나머지 항목들은 생성되는 객체를 잘 알고 있는 객체에게 책임을 할당하라고 이야기하고 있다.  

  
![스크린샷 2024-10-21 오후 2 36 15](https://github.com/user-attachments/assets/f54ddea4-98f3-4989-ab09-998f73381e0b)
**결합도**란 어느 한 객체가 다른 객체에 의존하는 정도를 의미한다.  
책임을 할당할 때는 가급적이면 전체적으로 결합도가 낮아지는 방향으로 책임을 할당해야 한다.  
낮은 결합도 패턴은 책임을 할당할 후보들 중에서 전체적으로 설계의 결합도를 낮출 수 있는 후배에게 책임을 할당하라고 조언한다.  
**결합도를 낮출 수 있는 후보에게 책임을 할당하면 수정하기 용이하고 재사용성이 높은 설계를 만들 수 있다.**  
  
<br>
<br>

### 높은 응집도 패턴
![스크린샷 2024-10-21 오후 3 08 18](https://github.com/user-attachments/assets/fd9cffb5-b3d5-4008-9e35-271119cc13bf)
GRASP 패턴에서는 낮은 결합도를 유지하고 변경에 따른 영향을 줄이면서 재사용성을 향상시키기 위해서는 높은 응집도를 유지하도록 책임을 할당해야 한다고 조언한다.  

  
![스크린샷 2024-10-21 오후 3 11 03](https://github.com/user-attachments/assets/4fcc39b1-43b9-419c-ad8f-4d1fd0bdf795)
**높은 응집도란 서로 밀접한 관련성을 가진 책임들만 같은 객체에 할당해야 한다.**  
객체지향에서는 유사한 책임들이 함께 모여 있을 경우에는 응집도가 높다고 이야기하고 이질적인 책임들이 함께 모여 있을 경우에는 응집도가 낮다고 이야기한다.  
이렇게 연관성 높은 책임들을 객체에 할당하고 연관성이 낮은 책임들을 다른 객체로 이동시켜면 하나의 객체가 너무 많은 일을 하게 되는 일을 방지할 수 있다.  
  
  
![스크린샷 2024-10-21 오후 3 21 21](https://github.com/user-attachments/assets/b7925514-b4a7-4c8a-89c3-9260e3d26211)
서로 연관성이 적은 책임이 하나의 객체 안에 모여 있으면(서로 상관없는 데이터와 로직) 코드를 읽을 때 수정할 부분을 찾기가 어려워진다.  
서로 다른 책임이 하나의 코드 안에 함께 공존하기 때문에 어떤 책임을 부연한 코드를 수정하면 이 책임과는 아무런 상관이 없는 다른 코드가 영향을 받을 가능성도 높아진다.  
**따라서 응집도가 낮으면 코드를 이해하기도 어렵고 수정으로 인한 버그가 발생할 활률도 높아진다.**

높은 응집도 패턴은 책임을 할당할 때 낮은 결합도 패턴과 함께 설계의 품질을 평가하기 위한 기준으로 사용된다.  
**두 객체 중에 어떤 객체에게 책임을 할당할지 판단하기 어렵다면 설계 전체적으로 응집도를 높일 수 있는 객체에게 책임을 할당하는 것이 좋다.**  

설계의 목적은 코드를 수정하기 쉽게 만드는 것이다.  
**수정하기 쉬운 코드를 얻기 위해서는 협력을 구성하는 객체의 응집도는 높이고 객체들 사이의 결합도는 낮춰야 한다.**  

설계를 하는 매 순간마다 여러 가지 대안 중에서 하나를 선택해야 한다.(트레이드 오프)  
설계를 배우는 과정은 다양한 상황에서 결정을 내리는데 필요한 여러 가지 판단 기준을 익히는 것과 같다.  
  
![스크린샷 2024-10-21 오후 3 34 13](https://github.com/user-attachments/assets/998b3c5f-7567-4d56-a37a-448bc096c28e)
DiscountPolicy 클래스의 응집도가 낮기 때문에 할인 정책이 추가될 때 마다 Movie 클래스도 변경이 발생한다.  
  
![스크린샷 2024-10-21 오후 3 39 14](https://github.com/user-attachments/assets/48a72993-b952-4652-b658-113027058ee1)
DiscountPolicy 클래스 안에는 서로 상관없는 메서드들이 공존하고 있기 떄문에 Movie 클래스는 이 중에서 적합한 메서드를 호출하기 위해 조건문을 추가했다.  
Movie 클래스는 할인 정책을 책임지지 않지만 응집도가 낮은 DiscountPolicy와 협력한다는 이유만으로 할인 정책을 추가할 때 함께 수정되고 있다.  
이러한 문제가 발생하는 이유는 Movie 클래스가 DiscountPolicy와 강하게 결합되어 있기 때문이다.
  
<br>
<br>
  
### 다형성 패턴
![스크린샷 2024-10-21 오후 3 47 14](https://github.com/user-attachments/assets/26180ec8-a7e8-4e23-a4a8-90d7601ad84d)
타입을 기반으로 유사하지만 서로 다르게 핼동하는 객체들이 존재할 때 다형성 패턴을 적용한다.  
  
![스크린샷 2024-10-21 오후 3 48 46](https://github.com/user-attachments/assets/a6c44124-6202-4221-a1ac-d1127db1c29e)
행동을 분기하기 위해(시스템의 행동을 확장) 조건문을 사용하면 새로운 행동을 추가하기 위해 조건문을 수정해야 한다.  
  
![스크린샷 2024-10-21 오후 3 52 47](https://github.com/user-attachments/assets/e02ff2bc-65b3-4fd3-a604-677aec30206d)
조건문을 사용하지 않고 변하는 행동을 처리하고 싶을 때 다형성 패턴을 사용한다.  

![스크린샷 2024-10-21 오후 3 54 29](https://github.com/user-attachments/assets/9dc1bb0c-23db-4815-a248-4a5a82b71230)
Movie 클래스 입장에서는 할인 정책을 사용할 때 여러 개 중에서 하나를 선택해야 한다.  
이러한 상황을 Movie 클래스 입장에서는 변하는 행동으로 보여진다.  
다형성 패턴에 따르면 이렇게 변하는 행동들은 하나의 객체 안에 함께 두면 안 되고 각각의 행동을 수행하는 독립적인 타입으로 분리해야 한다.  
다시 말해, 유사해 보이지만 서로 다르게 동작하는 책임이 하나의 후보안에 뭉쳐 있다면 타입을 분리한 후에 서로 다른 책임은 서로 다른 타입의 객체에게 할당해야 한다.  
따라서 금액 할인 정책이라는 좀 더 특화된 타입(비율 할인 클래스, 금액 할인 클래스로 분리)의 할인 금액을 계산하는 책임을 할당해야 한다.  
  
![스크린샷 2024-10-21 오후 4 06 22](https://github.com/user-attachments/assets/fed37be0-a963-4d25-a9b4-90e2ba38d026)
![스크린샷 2024-10-21 오후 4 37 34](https://github.com/user-attachments/assets/bc1fde8d-d246-4b89-ba5f-86b44a9f2fe4)
독립적인 타입으로 분리하였지만, 여전히 조건문을 통해 할인 금액을 가져오고 있고 다른 정책이 추가될 때 마다 Movie 클래스도 변경이 발생하므로 여전히 결합도가 높다고 볼 수 있다.  
  
![스크린샷 2024-10-21 오후 4 39 22](https://github.com/user-attachments/assets/5b8cccd7-6486-4fbe-b464-5160fae98f06)
객체지향에서 한 객체가 다른 객체와 협력하기 위해 보내는 요청을 메시지라고 부른다.
메시지는 객체가 협력을 위해 사용할 수 있는 유일한 의사소통 수단이다.

<br>
<br>

### 변경 보호 패턴
![스크린샷 2024-10-21 오후 4 43 55](https://github.com/user-attachments/assets/f7ec8dc3-e0c6-4080-ba05-90f46bf51440)
변경 보호 패턴은 할인 정책의 종류처럼 불안정하게 변하는 요소에 강하게 결합되기 때문에 수정하기 어려운 코드가 만들어지는 문제를 해결하기 위한 패턴이다.  
변경 보호 패턴을 적용해서 결합도를 낮추기 위해서는 변하는 부분을 식별하고 변하는 부분 주변에 안정적인 인터페이스나 추상화를 도입해야 한다.  

![스크린샷 2024-10-21 오후 4 46 38](https://github.com/user-attachments/assets/3ff88b1d-d146-4175-8447-1105515be27f)
**다형성이란 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행하는 행동이 달라지는 능력이다.**  
변화하는 대상인 비율 할인 정책과 금액 할인 정책 타입 주변에 할인 정책이라는 추상화를 추가한다.  
Movie 클래스에서는 추가한 인터페이스에게만 의존하도록 한다.  

![스크린샷 2024-10-21 오후 4 50 59](https://github.com/user-attachments/assets/a14f3759-9f5d-493e-a55e-68e26b71ce5e)
**구체적인 타입들로 대체 가능한 추상화를 역할이라고 부른다.**
만약 한 종류의 객체만 역할을 대체한다면 객체와 역할은 동일하다고 볼 수 있다.  
하지만 여러 종류의 객체가 대체할 수 있다면 역할은 객체와 동일하지 않으며 이 경우 역할은 객체가 대체할 수 있는 추상화를 의미한다.  

![스크린샷 2024-10-21 오후 4 54 11](https://github.com/user-attachments/assets/291fd4f6-aeba-4b42-b150-bca3491e8585)
협력 : 한 객체가 다른 객체에게 메시지를 전송해서 도움을 요청하고 응답을 받는 과정이다.  
책임 : 객체가 다른 객체와 협력하기 위해 알아야 하거나 행동해야 하는 것을 의미한다.  
역할 : 협력 안에서 책임을 수행하는 대상이다. (객체가 하나일 땐 역할 = 객체, 여러개일 땐 역할은 추상화)  
**역할, 책임, 협력이 책임 주도 설계를 구성하는 핵심적인 요소가 된다.**  

![스크린샷 2024-10-21 오후 5 04 08](https://github.com/user-attachments/assets/1b6d3226-9ef0-4bf2-b069-ee7cd8c4354a)
![스크린샷 2024-10-21 오후 5 02 50](https://github.com/user-attachments/assets/fbe02e61-6a89-4e1b-9ce0-6255fbf0b511)
DiscountPolicy 입장에서도 여러 개의 할인 조건 사용하기 때문에 결합도가 높고, 변경에 취약하다.  
따라서, 다형성 패턴과 변경 보호 패턴을 조합해서 결합도를 낮출 필요가 있다.  
먼저 다형성 패턴을 이용해서 다형적인 메시지로 요청을 통합한다.  
그후에 변경 보호 패턴을 이용해서 할인조건이라는 안정적인 추상화를 추가하고, 할인 정책이 추상화에 의존하도록 수정한다.  
이렇게 할 경우 결합도가 낮아졌기 떄문에 새로운 할인 조건을 추가하더라도 협력하는 할인정책에는 영향을 미치지 않는다.  
  
<br>
<br>

### 객체의 행동을 먼저 구현하고 행동에 필요한 데이터를 나중에 할당하라.
![스크린샷 2024-11-04 오전 9 41 54](https://github.com/user-attachments/assets/71b787b0-e97e-429d-afcd-c27f1720dfe5)
![스크린샷 2024-11-04 오전 9 42 08](https://github.com/user-attachments/assets/8457f211-cb98-4ee7-8450-8fc00be217f5)
![스크린샷 2024-11-04 오전 9 42 24](https://github.com/user-attachments/assets/4c29099e-e4ae-4b2b-b45c-32f03150920c)
![상영에 데이터 추가하기](https://github.com/user-attachments/assets/3d592813-ccc8-4179-bd0b-4fed33c45837)
예매객체를 생성하기 위해서는 영화의 가격이 필요한데, 응집도 관점에서 상영이 가격을 직접 계산하는 것 보단, 영화에게 가격 계산을 요청하는 것이 좋다.  
가격이라는 책임을 영화객체가 갖게하고, **협력(Movie 필드 선언, calculateFee() 요청)**을 통해 가격을 요청한다.  
위와 같이 행동을 머저 구현하고 행동에 필요한 데이터(Movie 필드)를 나중에 추가하는 방식으로 클래스를 구현한다. (책임지도 설계)  
**책임지도 설계의 기본 개념은 협력을 통해 현재 객체가 할 수 없는 일을 다른 객체에게 요청함으로써 객체가 할 수 있는 일보다 더 큰 작업을 수행할 수 있게 만드는 것이다.**  
  
  
![영화와 할인 정책 협력 구현하기](https://github.com/user-attachments/assets/9e8f2af9-8d93-4002-b5b4-ece3c93fdfe4)
![영화에 데이터 추가하기](https://github.com/user-attachments/assets/2a3bb944-b7ea-4b26-8a80-333443c5327e)
영화는 계산이라는 책임을 가지고 있다.  
영화의 가격을 계산을 하기 위해서는 할인 금액이 필요하다.  
영화는 할인금액을 계산하기 위해 할인정책에게 할인요금을 계산할 것을 요청(영화와 할인정책의 협력 dicountPolicy.calculateDiscount())한다.  
  
  
![다형성 패턴 적용하기](https://github.com/user-attachments/assets/e3a02efd-2e64-4659-b985-cb3e7ae1da2e)
영화에서 할인 정책에게 할인율을 계산해달라고 요청했을 때 다형성 패턴이 적용된 할인 정책 추상화 객체에 요청을 했다. (영화에서는 어느 할인 정책을 썼는지 알 필요가 없다.)  
할인 정책처럼 여러 객체에 의해 대체될 수 있는 추상화를 역할이라고 부른다.  
  
  
![역할 구현하기](https://github.com/user-attachments/assets/2154add2-b2f7-492f-90d1-e6e303f44030)
역할을 구현하는 방법은 다양하다.  
1. 역할이 오직 하나의 객체만 표현한다면 구체 클래스로 구현.  
2. 여러 객체에 대체될 수 있고 코드를 공유할 필요가 있다면 추상 클래스를 이용해서 구현.  
3. 코드를 공유할 필요도 없고 결합도를 낮추기 위한 메시지 수신자의 역할만 명시하기를 원한다면 인터페이스를 이용해서 구현.


![할인 정책 역할 구현하기](https://github.com/user-attachments/assets/2450560a-b1fa-4f90-8583-d80095316f4f)
![할인 정책 역할 구현하기](https://github.com/user-attachments/assets/dc344f3d-3589-49d6-af72-95173927f779)
![할인 정책 역할 구현하기](https://github.com/user-attachments/assets/cbfdbfdc-c873-4a9d-900a-ae4a0c7b7499)
![할인 정책 역할 구현하기](https://github.com/user-attachments/assets/f9113ef7-0935-4cb6-9e60-c1dfbc4a535e)
![비율 할인 정책 구현하기](https://github.com/user-attachments/assets/f66c0bb4-1397-42a1-8969-2b295433cc57)
할인 정책의 경우에는 금액 할인 정책과 비율 할인 정책 사이에 데이터와 로직을 공유해야하기 때문에 추상 클래스로 구현하였다.


![절차적인 방식과 객체지향 방식의 차이](https://github.com/user-attachments/assets/9054c277-d0af-40cb-9be4-04390428218f)
절차적인 방식으로 설계된 객체는 피해 속성이 사용될 문맥을 고려하지 않고 막연한 추측을 기반으로 모든 필드에 대해 getter, setter 메서드를 추가하였다. (추측에 기반한 설계)  
반면에, 객체지향 방식으로 설계된 객체는 협력을 설계하는 과정에서 영화의 정가를 제공하는 책임을 할당했고, 이 책임을 구현하는데 필요한 피해 필드를 나중에 추가하였다. (꼭 필요한 코드만 설계)  
