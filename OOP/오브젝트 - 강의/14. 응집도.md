## 응집도
![스크린샷 2024-11-21 오후 3 30 22](https://github.com/user-attachments/assets/c7bbc857-abd4-4182-ac2d-4e8a3390d3e8)  
**전통적인 관점에서 응집도는 모듈 내부의 요소들이 하나의 기능에 집중하는 정도 또는 데이터와 메서드가 서로 관련된 정도를 의미한다.**  
<br>

### 변경 관점에서의 응집도
![스크린샷 2024-11-21 오후 3 31 44](https://github.com/user-attachments/assets/c1ab0277-9111-4676-be32-0592eb75eb32)
변경 관점에서 응집도는 모듈 내부 요소들이 함께 변경되는 정도를 의미한다.  
모듈 안에 포함된 모든 요소들이 동일한 이유로 함께 변경된다면 응집도가 높다고 볼 수 있다.  
반대로 모듈 안에 포함된 요소들이 서로 다른 이유로 변경된다면 응집도가 낮다고 볼 수 있다.  

변경 관점에서 응집도를 이야기할 때는 변경의 시점과 속도(변경의 빈도)가 중요하다.  
모듈 전체의 코드가 동일한 시점에 동일한 속도로 변경된다면 응집도가 높은 모듈이다.  
반대로 모듈을 구성하는 요소들이 서로 다른 시점에 서로 다른 속도로 변경된다면 응집도가 낮은 모듈이다.  
<br>

### 절차적인 예매 모듈(하나의 메서드에 모든 책임을 가지고 있다.)
![스크린샷 2024-11-21 오후 3 36 48](https://github.com/user-attachments/assets/7c41c023-6768-4d86-b9ab-346489b3aa00)
reserveScreening() 에서 사용되는 메서드가 각각의 다른 이유로 변경이 일어난다면 응집도가 낮은 메서드라고 볼 수 있다.  
<br>

### 객체지향 예매 모듈(모든 클래스가 각각의 책임을 가지고 있고, 어떠한 로직이 변경될 때 해당되는 클래스만 변경이 발생한다.)
![스크린샷 2024-11-21 오후 3 38 31](https://github.com/user-attachments/assets/d77249ff-7a16-4815-a5b6-57e8e8f54b06)
객체지향적으로 작성된 코드에서 각 클래스는 단 하나의 이유때문에 변경된다.  
각 클래스는 동일한 이유로 함께 변경되는 데이터와 메서드로 구성되어 있다.  
따라서, 객체지향적으로 작성된 설계는 응집도가 높다고 말할 수 있으며, 응집도가 높은 객체는 단일책임원칙(SRP)을 지킨 설계라고 볼 수 있다.  
<br>

### 응집도를 높이는 원칙
클래스 안에 변경의 이유가 서로 다른 코드에 존재한다면 별도의 클래스로 분리해야 한다.  
**클래스의 라인 수가 중요한 게 아니라 변경의 이유가 중요하다.**  
서로 다른 이유로 변경된다면 코드가 한 줄이고 메서드가 하나라도 별도의 클래스로 분리하는 것이 좋다.  
<br>

### 응집도를 높이기 위한 분리 기준
![스크린샷 2024-11-21 오후 3 46 48](https://github.com/user-attachments/assets/8914b6d5-6b5f-45d4-a2de-7151a6784d61)
**1. 클래스 전체가 아닌 일부 메서드와 속성만 변경하고 있다면 응집도가 낮은 것이다.**  
따라서, 변경의 이유에 따라 수정되는 부분을 별도의 클래스로 분리해서 응집도를 높여야 한다.  
  
**2. 특정한 메서드 그룹이 특정한 속성 그룹만 사용한다면 응집도가 낮은 것이다.**  
따라서, 함께 사용되는 메서드와 속성을 별도의 클래스로 분리해야 한다.  

**3. 객체를 생성할 때 모든 속성을 함께 초기화하지 않고 일부 속성을 null로 설정한다면 응집도가 낮은 것이다.**  
따라서, 초기화되는 속성의 그룹을 기준으로 클래스를 분리해야 한다.  













































