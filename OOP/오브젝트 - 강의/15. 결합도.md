## 결합도
![스크린샷 2024-11-21 오후 3 50 40](https://github.com/user-attachments/assets/bdc3be11-6d95-48fe-8496-69bd71363e1f)
**전통적인 관점에서 결합도는 모듈이 외부 다른 모듈에 의존하는 정도를 의미한다.**  
<br>

### 절차적인 에매 로직
![스크린샷 2024-11-21 오후 3 51 53](https://github.com/user-attachments/assets/cecbd936-96c5-4241-9a16-b309a4bae548)
ReservationService의 calculateDiscount()는 할인금액을 계산하기 위해 DiscountPolicy를 사용한다.  
ReservationService는 DiscountPolicy에 의존한다고 볼 수 있다.  
따라서 ReservationService 클래스는 DiscountPolicy 클래스 이름에 의존하고, DiscountPolicy 클래스의 메서드 시그니처에 의존한다.  
<br>

### 객체지향 예매 로직
![스크린샷 2024-11-21 오후 3 56 05](https://github.com/user-attachments/assets/6962f74b-aa15-4479-8f97-3fa0b9c0ba45)
Movie 클래스는 DiscountPolicy 클래스의 이름이 포함되어 있기 때문에 클래스 이름에 의존된다고 볼 수 있다.  
또한, DiscountPolicy 클래스의 calculateDiscount() 도 사용하고 있기 때문에 메서드 시그니처에 의존한다고 볼 수 있다.  

이런 상황에서만 보면 절차적인 예매 로직과 동일한 결합도를 가진다고 생각할 수 있지만, 변경 관점에서 결합도를 살펴봐야 한다.  
<br>

### 변경 관점에서의 결합도
![스크린샷 2024-11-21 오후 4 01 55](https://github.com/user-attachments/assets/78ac641d-215b-45a7-bb61-dc1fbb972d99)
**변경 관점에서 결합도는 외부 모듈이 변경될 때 함께 변경되는 정도를 의미한다.**  
외부의 모듈이 변경될 때 함께 변경되는 빈도가 높을 경우에는 결합도가 높다고 이야기한다.  
반대로, 외부의 모듈이 변경될 때 함께 변경되는 빈도가 낮을 경우에는 결합도가 낮다고 이야기한다.  
<br>

### 의존성과 결합도
![스크린샷 2024-11-21 오후 4 03 59](https://github.com/user-attachments/assets/cceeb3e9-7f5b-4d87-b8c3-163999321355)
![스크린샷 2024-11-21 오후 4 07 27](https://github.com/user-attachments/assets/096849f3-bb8f-4d97-b674-886109ca3f35)
의존성과 결합도는 밀접하게 연관되어 있는 개념이다.  
의존성은 외부의 모듈이 변경될 때 함께 변경될 수 있는 가능성을 의미한다.  
변경될 가능성이 있다면 의존성이 있다고 볼 수 있고, 변경될 가능성이 없다면 의존성이 없다고 볼 수 있다.  
결합도는 의존성이 존재하는 전제하에 변경에 의한 영향의 정도를 표한한다.  
**의존성이 변경 가능성의 존재 유무를 의미한다면, 결합도는 변경이 얼마나 자주 발생하는지를 의미한다.**  
**따라서, 결합도는 상대적인 것이다.**  

위 그림과 같이 의존중인 클래스(B)가 변경될 때, 해당 클래스(A)의 변경이 많다면 높은 결합도를 가진다고 말한다.  
**좋은 설계는 결합도가 낮은 설계이고, 결합도가 낮은 설계는 함께 변경될 가능성이 낮은 설계이다.**  
따라서 설계를 개선하기 위해서는 함께 변경될 가능성을 낮춰야 한다.  

결합도의 개념을 이해하면 의존성을 제어하는데 사용할 수 있는 중요한 원칙을 이해할 수 있게된다.  
의존성을 제어하는 이유는 결합도를 낮춰서 함꼐 변경되는 빈도를 줄이기 위해서다.  
<br>

### 결합도 낮추기
![스크린샷 2024-11-21 오후 6 41 41](https://github.com/user-attachments/assets/925d31ea-2644-4f95-afb9-f914a77fedea)
합도를 낮추기 위해서는 자주 변하는 부분이 아니라 변하지 않는 안정적인 부분에 의존하도록 의존성을 제어해야 한다.  
위 그림과 같이 A가 B에 의존한다면 B에서 자주 변하지 않는 안정적인 부분을 자주 변하는 불안정한 부분으로부터 코드 안에서 명확하게 분리해야 한다.  
그 후에 A가 B의 안정적인 부분에만 의존하도록 의존성을 제어해야 한다.  

**추상화 : 자주 변하지 않는 안정적인 부분**  
**구현 : 자주 변하는 불안정한 부분**  
  
![스크린샷 2024-11-21 오후 6 45 26](https://github.com/user-attachments/assets/37b8bb7b-e1b4-4534-9b48-05e503d7df7c)
**결합도를 낮추기 위한 방법은 구현과 추상화를 분리하고 구현이 아닌 안정적인 추상화에 의존하도록 의존성을 제어하는 것이다.**  
이렇게 추상화에 의존하도록 의존성을 제어하면 구현이 변경되더라도 추상화를 경계로 변경의 여파가 외부로 전파되는 것을 막을 수 있다.  

**이 관점에서 모듈 내부의 구현을 변경했을 때 외부의 모듈이 영향을 받는다면 결합도가 높다고 볼 수 있고, 외부의 모듈이 영향을 받지 않는다면 결합도가 낮다고 볼 수 있다.**  
**협력이라는 문맥에서 추상화를 인터페이스라고 부른다.**  
**협력 관점에서 추상화와 구현을 분리해서 결합도를 낮추는 원칙을 인터페이스와 구현의 분리 원칙이라고 부른다.**  























