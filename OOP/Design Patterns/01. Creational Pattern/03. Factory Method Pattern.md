## 팩토리 메서드 패턴 (Factory Method Pattern)
<img width="908" alt="스크린샷 2024-11-22 오후 3 33 24" src="https://github.com/user-attachments/assets/838b905c-3e32-4a62-94ed-eba777709ebd">

추상 팩토리 패턴은 서로 관련된 객체들의 **'제품군(family)'** 을 생성하기 위한 인터페이스를 제공한다.  
이를 통해 구체적인 클래스에 의존하지 않고도 객체들을 생성할 수 있으며, 다양한 제품군을 손쉽게 교체할 수 있다.  
이 패턴은 객체 생성에 관한 추상화를 제공하여 시스템의 유연성과 확장성을 높인다.
<br>
<br>

### 사용 목적
**관련된 객체들의 생성** : 관련성 있는 여러 객체들을 생성할 수 있다.  
**구체적인 클래스 의존성 제거** : 클라이언트 코드가 구체적인 클래스에 의존하지 않도록 하여 결합도를 낮춘다.  
**구현체 교체 용이성** : 구현체 전체를 쉽게 교체할 수 있어 시스템의 유연성이 높아진다.  
**일관성 유지** : 동일한 팩토리를 통해 생성된 객체들은 서로 호환되며, 제품들 간의 일관성을 유지한다.
<br>
<br>

### 구성 요소
**AbstractFactory (추상 팩토리)**  
관련된 객체들을 생성하기 위한 인터페이스를 선언한다.  
각 제품에 해당하는 생성 메서드를 정의합니다.  
  
**ConcreteFactory (구체 팩토리)**  
AbstractFactory 인터페이스를 구현하여 특정 제품군의 객체들을 생성한다.  
각 제품에 대한 구체적인 생성 메서드를 제공한다.  
  
**AbstractProduct (추상 제품)**  
제품 객체들이 구현해야 할 공통 인터페이스를 정의한다.  
제품의 공통 기능을 선언한다.  
  
**ConcreteProduct (구체 제품)**  
AbstractProduct 인터페이스를 구현하여 실제 제품 객체를 제공한다.  
각 구체적인 팩토리에서 생성된다.  
  
**Client (클라이언트)**  
AbstractFactory와 AbstractProduct 인터페이스를 사용하여 객체를 생성하고 사용한다.  
구체적인 클래스에 의존하지 않으므로 제품군이 변경되어도 코드 수정을 최소화할 수 있다.  


### 예제
**여러 인터페이스 클래스**  
```java
interface Button {
    void paint();
}

// 추상 제품 B
interface Checkbox {
    void paint();
}
```

**구체 클래스**  
```java
class WindowsButton implements Button {
    public void paint() {
        System.out.println("Windows 스타일 버튼을 그립니다.");
    }
}

// 구체 제품 B1
class WindowsCheckbox implements Checkbox {
    public void paint() {
        System.out.println("Windows 스타일 체크박스를 그립니다.");
    }
}

// 구체 제품 A2
class MacOSButton implements Button {
    public void paint() {
        System.out.println("MacOS 스타일 버튼을 그립니다.");
    }
}

// 구체 제품 B2
class MacOSCheckbox implements Checkbox {
    public void paint() {
        System.out.println("MacOS 스타일 체크박스를 그립니다.");
    }
}
```

**추상 팩토리**  
```java
interface GUIFactory {
    Button createButton();
    Checkbox createCheckbox();
}
```

**구체 팩토리**  
```java
// 구체 팩토리 1
class WindowsFactory implements GUIFactory {
    public Button createButton() {
        return new WindowsButton();
    }
    public Checkbox createCheckbox() {
        return new WindowsCheckbox();
    }
}

// 구체 팩토리 2
class MacOSFactory implements GUIFactory {
    public Button createButton() {
        return new MacOSButton();
    }
    public Checkbox createCheckbox() {
        return new MacOSCheckbox();
    }
}
```

**클라이언트 코드**  
```java
class Application {
    private Button button;
    private Checkbox checkbox;

    public Application(GUIFactory factory) {
        button = factory.createButton();
        checkbox = factory.createCheckbox();
    }

    public void paint() {
        button.paint();
        checkbox.paint();
    }
}

class Client {
    public static void main(String[] args) {
        GUIFactory factory;
        String osName = System.getProperty("os.name").toLowerCase();

        if (osName.contains("win")) {
            factory = new WindowsFactory();
        } else if (osName.contains("mac")) {
            factory = new MacOSFactory();
        } else {
            throw new UnsupportedOperationException("지원하지 않는 운영체제입니다.");
        }

        Application app = new Application(factory);
        app.paint();
    }
}
```

### 팩토리 메서드 패턴과의 차이점
팩토리 메소드 패턴 : “팩토리를 구현하는 방법 (inheritance)”에 초점을 둔다.  
목적 : **구체적인 객체 생성 과정을 하위 또는 구체적인 클래스로 옮기는 것이 목적.**  
  
추상 팩토리 패턴 : “팩토리를 사용하는 방법 (composition)”에 초점을 둔다.  
목적 : **관련있는 여러 객체를 구체적인 클래스에 의존하지 않고 만들 수 있게 해주는 것이 목적.**
<br>
<br>

### 장점 
**교체 가능성** : 새로운 팩토리를 사용하여 제품군 전체를 교체할 수 있으므로, 시스템의 유연성이 높아집니다.  
**일관성 보장** : 동일한 팩토리를 사용하여 생성된 객체들은 서로 호환되며, 제품들 간의 일관성을 유지합니다.  
**결합도 감소** : 클라이언트가 구체적인 클래스에 의존하지 않으므로, 시스템의 결합도가 낮아집니다.  

### 단점
**확장성 제한** : 새로운 제품 유형을 추가하려면 추상 팩토리와 모든 구체적인 팩토리를 수정해야 하므로, 개방-폐쇄 원칙에 위배될 수 있습니다.  
**복잡성 증가** : 클래스와 인터페이스의 수가 증가하여 코드 구조가 복잡해질 수 있습니다.  



















