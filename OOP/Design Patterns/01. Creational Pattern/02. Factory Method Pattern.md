## 팩토리 메서드 패턴 (Factory Method Pattern)
<img width="561" alt="스크린샷 2024-11-22 오후 2 46 08" src="https://github.com/user-attachments/assets/17b5913a-6e5a-4b5b-9a9c-7b334730c84b">  

팩토리 메서드 패턴은 객체 생성 코드를 서브클래스에 위임하여 객체 생성의 인터페이스는 유지하면서 실제 생성되는 객체의 클래스를 변경할 수 있도록 하는 패턴이다. 이 패턴은 객체 생성 로직을 캡슐화하여 코드의 유연성과 확장성을 높이고, 클라이언트 코드가 구체적인 클래스에 의존하지 않도록 한다.  
<br>

### 사용하는 목적
1. 객체 생성의 책임을 서브클래스로 분리하여 코드의 결합도를 낮춘다.
2. 새로운 객체 유형을 추가하더라도 클라이언트 코드를 수정하지 않고 확장할 수 있다.
3. 객체 생성 과정을 통제하여 객체의 생성 및 초기화를 일관성 있게 관리한다.
<br>

### 구성 요소
**Product (제품) 인터페이스 또는 추상 클래스**  
생성될 객체들이 구현해야 할 공통 인터페이스나 추상 클래스를 정의합니다.  
  
**ConcreteProduct (구체적인 제품) 클래스들**  
Product 인터페이스를 구현한 실제 객체들로, 팩토리 메서드에서 생성됩니다.  
  
**Creator (창조자) 추상 클래스**  
팩토리 메서드를 선언하고, 이 메서드를 통해 Product 객체를 반환합니다.  
팩토리 메서드는 기본 구현을 제공하거나 추상 메서드로 선언될 수 있습니다.  
  
**ConcreteCreator (구체적인 창조자) 클래스들**  
Creator 클래스를 상속하며, 팩토리 메서드를 오버라이드하여 특정 ConcreteProduct 객체를 생성합니다.  
<br>

### 예제
**공통 추상 클래스**  
```java
abstract class Document {
    public abstract void open();
    public abstract void close();
}
```

**ConcreteProduct 클래스**  
```java
class WordDocument extends Document {
    @Override
    public void open() {
        System.out.println("Word 문서를 엽니다.");
    }
    @Override
    public void close() {
        System.out.println("Word 문서를 닫습니다.");
    }
}

class PDFDocument extends Document {
    @Override
    public void open() {
        System.out.println("PDF 문서를 엽니다.");
    }
    @Override
    public void close() {
        System.out.println("PDF 문서를 닫습니다.");
    }
}
```

**Creator 추상 클래스**  
```java
abstract class Application {
    public void newDocument() {
        Document doc = createDocument();
        doc.open();
    }
    // 팩토리 메서드
    protected abstract Document createDocument();
}
```

**ConcreteCreator 클래스들**  
```java
class WordApplication extends Application {
    @Override
    protected Document createDocument() {
        return new WordDocument();
    }
}

class PDFApplication extends Application {
    @Override
    protected Document createDocument() {
        return new PDFDocument();
    }
}
```

**클라이언트 코드**  
```java
public class Client {
    public static void main(String[] args) {
        Application app = new WordApplication();
        app.newDocument(); // Word 문서를 생성하고 열기

        app = new PDFApplication();
        app.newDocument(); // PDF 문서를 생성하고 열기
    }
}
```

### 장점
1. 크리에이터와 구상 제품들이 느슨한 결합이 될 수 있도록 한다.
2. 단일 책임 원칙. 각각의 클래스는 하나의 책임만을 가지고 있기 때문에 더 쉽게 유지관리할 수 있다.
3. 개방/폐쇄 원칙. 기존 클라이언트 코드의 변경없이 새로운 유형의 제품들을 프로그램에 도입할 수 있다.

### 단점
1. 패턴을 구현하기 위해 새로운 자식 클래스들을 계속해서 구현해야 하므로 코드가 더 복잡해질 수 있다.
