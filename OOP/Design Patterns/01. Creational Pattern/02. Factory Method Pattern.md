## 팩토리 메서드 패턴 (Factory Method Pattern)
<img width="561" alt="스크린샷 2024-11-22 오후 2 46 08" src="https://github.com/user-attachments/assets/17b5913a-6e5a-4b5b-9a9c-7b334730c84b">  

팩토리 메서드 패턴은 객체 생성 코드를 서브클래스에 위임하여 객체 생성의 인터페이스는 유지하면서 실제 생성되는 객체의 클래스를 변경할 수 있도록 하는 패턴이다. 이 패턴은 객체 생성 로직을 캡슐화하여 코드의 유연성과 확장성을 높이고, 클라이언트 코드가 구체적인 클래스에 의존하지 않도록 한다.  

### 사용하는 목적
1. 객체 생성의 책임을 서브클래스로 분리하여 코드의 결합도를 낮춘다.
2. 새로운 객체 유형을 추가하더라도 클라이언트 코드를 수정하지 않고 확장할 수 있다.
3. 객체 생성 과정을 통제하여 객체의 생성 및 초기화를 일관성 있게 관리한다.
<br>

### 예제
**Dialog.java: 공통 제품 인터페이스**
```java
public abstract class Dialog {

    public void renderWindow() {
        // ... 생략 ...

        Button okButton = createButton();
        okButton.render();
    }

    public abstract Button createButton();
}
```

**공통 인터페이스 상속**
```java
public class WindowsDialog extends Dialog {

    @Override
    public Button createButton() {
        return new WindowsButton(); // 실제 동작하는 기능
    }
}

public class IOSDialog extends Dialog {

    @Override
    public Button createButton() {
        return new IOSButton(); // 실제 동작하는 기능
    }
}
```

**적용**
```java
public class Main {
    private static Dialog dialog; // Dialog 인터페이스

    public static void main(String[] args) {
        configure();
        runBusinessLogic();
    }

    static void configure() {
        // 조건에 맞는 구현체 적용
        if (System.getProperty("os.name").equals("Windows 10")) {
            dialog = new WindowsDialog();
        } else {
            dialog = new IOSDialog();
        }
    }

    static void runBusinessLogic() {
        dialog.renderWindow();
    }
}
```

### 장점
1. 크리에이터와 구상 제품들이 느슨한 결합이 될 수 있도록 한다.
2. 단일 책임 원칙. 각각의 클래스는 하나의 책임만을 가지고 있기 때문에 더 쉽게 유지관리할 수 있다.
3. 개방/폐쇄 원칙. 기존 클라이언트 코드의 변경없이 새로운 유형의 제품들을 프로그램에 도입할 수 있다.

### 단점
1. 패턴을 구현하기 위해 새로운 자식 클래스들을 계속해서 구현해야 하므로 코드가 더 복잡해질 수 있다.
